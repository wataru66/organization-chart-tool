<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Organization Chart Tool v4 - With Table Editor</title>
    
    <!-- 外部ライブラリ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- 統合スタイル -->
    <style>
        /* 基本スタイル */
        body {
            font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f7fafc;
            color: #2d3748;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            position: relative;
        }

        .header-logo {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }

        .header-title {
            margin: 0;
            font-size: 29px;
            font-weight: bold;
            color: #2563eb;
        }
        
        /* File Upload Section */
        .file-upload-section {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .app-description {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .app-description h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #4b5563;
            font-weight: 600;
        }

        .app-description p {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #6b7280;
            line-height: 1.4;
        }

        .file-upload-container {
            padding: 10px;
            background: #f9fafb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* File Drop Zone */
        .file-drop-zone {
            width: 100%;
            max-width: 600px;
            height: 100%;
            min-height: 100px;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .file-drop-zone:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .file-drop-zone.drag-over {
            border-color: #3b82f6;
            background: #dbeafe;
            transform: scale(1.02);
        }
        
        .drop-zone-content {
            text-align: center;
            pointer-events: none;
        }
        
        .drop-zone-content svg {
            color: #6b7280;
            margin-bottom: 8px;
        }
        
        .drop-zone-content p {
            margin: 0;
            font-size: 14px;
            color: #4b5563;
            font-weight: 500;
        }
        
        .drop-zone-hint {
            font-size: 12px !important;
            color: #9ca3af !important;
            font-weight: normal !important;
            margin-top: 4px !important;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 0;
        }
        
        .workflow-section, .additional-section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
        }
        
        .workflow-section h3, .additional-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #4b5563;
            font-weight: 600;
        }
        
        .workflow-controls, .additional-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-group-vertical > .btn {
            width: 100%;
            min-width: unset;
        }
        
        .display-settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .setting-item label {
            min-width: 80px;
            font-size: 13px;
        }
        
        .setting-item select {
            flex: 1;
        }
        
        /* Table action buttons */
        .row-actions .btn {
            min-width: unset !important;
            border: 1px solid #ccc;
            border-radius: 2px;
        }
        
        .row-actions .btn:hover {
            background: #e9ecef;
        }
        
        /* Fixed columns for horizontal scroll */
        .table-wrapper {
            position: relative;
            overflow: auto;
            max-height: 600px;
            border: 1px solid #dee2e6;
        }
        
        .data-table {
            position: relative;
            table-layout: auto;
            border-collapse: separate;
            border-spacing: 0;
            min-width: 100%;
            border: none;
        }
        
        /* Base fixed column styles */
        .fixed-column {
            position: sticky !important;
            background: white !important;
            z-index: 20 !important;
            border-right: 2px solid #dee2e6 !important;
            box-shadow: 2px 0 4px rgba(0,0,0,0.1) !important;
        }
        
        /* Header fixed columns - higher z-index for sticky headers */
        .data-table thead .fixed-column {
            position: sticky !important;
            top: 0 !important;
            z-index: 30 !important;
            background: #f8f9fa !important;
        }
        
        /* Header row number special styling */
        .data-table thead .fixed-column.row-number {
            background: #e9ecef !important;
            z-index: 31 !important;
        }
        
        /* Row number column */
        .data-table .fixed-column.row-number,
        .data-table td.fixed-column.row-number,
        .data-table th.fixed-column.row-number {
            left: 0 !important;
            width: 40px !important;
            min-width: 40px !important;
            max-width: 40px !important;
        }
        
        /* Actions column */
        .data-table .fixed-column.actions,
        .data-table td.fixed-column.actions,
        .data-table th.fixed-column.actions {
            left: 40px !important;
            width: 80px !important;
            min-width: 80px !important;
            max-width: 80px !important;
        }
        
        /* Level column */
        .data-table .fixed-column.level,
        .data-table td.fixed-column.level,
        .data-table th.fixed-column.level {
            left: 120px !important;
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
        }
        
        /* Team Name column */
        .data-table .fixed-column.team-name,
        .data-table td.fixed-column.team-name,
        .data-table th.fixed-column.team-name {
            left: 180px !important;
            width: 200px !important;
            min-width: 200px !important;
            max-width: 200px !important;
        }
        
        /* Ensure proper stacking for corner headers */
        .data-table thead .fixed-column.row-number {
            z-index: 32 !important;
        }
        
        .data-table thead .fixed-column.actions {
            z-index: 31 !important;
        }
        
        .data-table thead .fixed-column.level {
            z-index: 31 !important;
        }
        
        .data-table thead .fixed-column.team-name {
            z-index: 31 !important;
        }
        
        /* Other data columns */
        .data-table td:not(.fixed-column),
        .data-table th:not(.fixed-column) {
            min-width: 150px;
            width: 150px;
            white-space: nowrap;
            overflow: visible;
            text-overflow: clip;
            padding: 8px 12px;
        }
        
        /* Specific column widths for better readability */
        .data-table th[data-column="teamName"],
        .data-table td[data-column="teamName"] {
            min-width: 200px !important;
            width: 200px !important;
        }
        
        .data-table th[data-column="role"],
        .data-table td[data-column="role"] {
            min-width: 180px !important;
            width: 180px !important;
        }
        
        .data-table th[data-column="picName"],
        .data-table td[data-column="picName"] {
            min-width: 160px !important;
            width: 160px !important;
        }
        
        .data-table th[data-column="upperTeam"],
        .data-table td[data-column="upperTeam"] {
            min-width: 180px !important;
            width: 180px !important;
        }
        
        .data-table th[data-column="teamBoss"],
        .data-table td[data-column="teamBoss"] {
            min-width: 60px !important;
            width: 60px !important;
            text-align: center !important;
        }
        
        .data-table th[data-column="concurrent"],
        .data-table td[data-column="concurrent"] {
            min-width: 60px !important;
            width: 60px !important;
            text-align: center !important;
        }
        
        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: #3b82f6;
            color: white;
            border-radius: 50%;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        @media (max-width: 1024px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .file-drop-zone {
                position: relative;
                top: auto;
                right: auto;
                width: 100%;
                margin: 20px 0;
            }
        }
        
        .chart-container {
            border: 1px solid #e2e8f0;
            min-height: 650px;
            background: white;
            overflow: auto;
            border-radius: 6px;
            position: relative;
        }
        
        .chart-content {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .chart-controls {
            position: absolute;
            top: 40px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }
        
        .chart-container.fullscreen .chart-controls {
            position: fixed;
            top: 60px;
            right: 20px;
            z-index: 1000;
        }
        
        .chart-control-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .chart-control-btn:hover {
            background: rgba(255, 255, 255, 1);
            border-color: #3b82f6;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .chart-control-btn .tooltip {
            position: absolute;
            bottom: 120%;
            right: 50%;
            transform: translateX(50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1001;
        }

        .chart-control-btn .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 50%;
            transform: translateX(50%);
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.8);
        }

        .chart-control-btn:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .chart-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            border-radius: 0;
            margin: 0;
        }
        
        .chart-container.zoomed {
            overflow: scroll;
        }
        
        .chart-container svg {
            transition: transform 0.3s ease;
        }
        
        .chart-container.dragging {
            cursor: grabbing;
        }
        
        .chart-container.draggable {
            cursor: grab;
        }
        
        .chart-container svg.dragging {
            transition: none;
        }
        
        .table-container {
            display: none;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            margin-top: 20px;
            overflow: auto;
        }
        
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            min-width: 150px;
            text-align: center;
        }
        
        /* Workflow section buttons */
        .workflow-controls .btn {
            min-width: 180px;
        }
        
        /* Export buttons in step 4 - match longest text */
        .workflow-controls .control-group:nth-child(4) .btn {
            min-width: 180px;
        }
        
        /* Table actions buttons - match workflow style */
        .table-actions .btn {
            min-width: 180px;
            font-size: 14px;
            padding: 8px 16px;
        }
        
        /* Chart generation options */
        .chart-options {
            margin-left: 10px;
            display: inline-flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Or text styling */
        .or-text {
            font-size: 14px;
            color: #6b7280;
            margin: 0 8px;
        }
        
        .chart-options .option-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .chart-options label {
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
        }
        
        .chart-options select {
            font-size: 12px;
            padding: 2px 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        #starting-team-select {
            min-width: 120px;
        }
        
        .btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        input, select {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #6b7280;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        .notification-success { background: #10b981; }
        .notification-error { background: #ef4444; }
        .notification-warning { background: #f59e0b; }
        .notification-info { background: #3b82f6; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .language-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        
        /* 組織図SVGスタイル */
        .org-chart-svg {
            width: 100%;
            height: 100%;
        }
        
        .org-box {
            cursor: pointer;
        }
        
        .org-box:hover .org-box-bg {
            stroke-width: 3;
        }
        
        .connection-line {
            stroke: #666;
            stroke-width: 2;
            fill: none;
        }
        
        /* テーブル編集スタイル */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .data-table th,
        .data-table td {
            border: 1px solid #e5e7eb;
            padding: 8px;
            text-align: left;
        }
        
        .data-table th {
            background: #f9fafb;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .data-table tbody tr:hover {
            background: #f3f4f6;
        }
        
        .cell-editor {
            width: 100%;
            padding: 4px;
            border: 2px solid #3b82f6;
            border-radius: 2px;
            font-size: 14px;
        }
        
        .table-actions {
            display: flex;
            gap: 10px;
            padding: 10px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .row-actions {
            display: flex;
            gap: 5px;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .color-input {
            width: 40px;
            height: 30px;
            padding: 2px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
        }
        
        /* レスポンシブ */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .controls { flex-direction: column; }
            .container { padding: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <svg class="header-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
                <!-- トップレベル -->
                <rect x="35" y="15" width="30" height="18" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                
                <!-- 接続線 -->
                <line x1="50" y1="33" x2="50" y2="40" stroke="#2563eb" stroke-width="2"/>
                <line x1="25" y1="40" x2="75" y2="40" stroke="#2563eb" stroke-width="2"/>
                <line x1="25" y1="40" x2="25" y2="47" stroke="#2563eb" stroke-width="2"/>
                <line x1="50" y1="40" x2="50" y2="47" stroke="#2563eb" stroke-width="2"/>
                <line x1="75" y1="40" x2="75" y2="47" stroke="#2563eb" stroke-width="2"/>
                
                <!-- セカンドレベル -->
                <rect x="10" y="47" width="30" height="16" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                <rect x="35" y="47" width="30" height="16" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                <rect x="60" y="47" width="30" height="16" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                
                <!-- 下位レベルへの接続線 -->
                <line x1="25" y1="63" x2="25" y2="70" stroke="#2563eb" stroke-width="2"/>
                <line x1="15" y1="70" x2="35" y2="70" stroke="#2563eb" stroke-width="2"/>
                <line x1="15" y1="70" x2="15" y2="77" stroke="#2563eb" stroke-width="2"/>
                <line x1="35" y1="70" x2="35" y2="77" stroke="#2563eb" stroke-width="2"/>
                
                <line x1="75" y1="63" x2="75" y2="77" stroke="#2563eb" stroke-width="2"/>
                
                <!-- サードレベル -->
                <rect x="5" y="77" width="20" height="12" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                <rect x="30" y="77" width="20" height="12" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
                <rect x="65" y="77" width="20" height="12" rx="2" fill="none" stroke="#2563eb" stroke-width="2"/>
            </svg>
            <h1 class="header-title" data-i18n="title">Organization Chart Tool v4</h1>
        </div>

        <!-- File Upload Section -->
        <div class="file-upload-section">
            <!-- App Description -->
            <div class="app-description">
                <h3 data-i18n="appDescriptionTitle">About This Tool</h3>
                <p data-i18n="appDescription1">Create beautiful organization charts from Excel data.</p>
                <p data-i18n="appDescription2">Upload your Excel file or use sample data to get started.</p>
                <p data-i18n="appDescription3">Features: Walker's Algorithm layout, interactive editing, multiple export formats.</p>
                <p data-i18n="appDescription4">For graphic editing, export as SVG and edit in PowerPoint, etc.</p>
            </div>
            
            <!-- File Upload Container -->
            <div class="file-upload-container">
                <div id="file-drop-zone" class="file-drop-zone">
                    <div class="drop-zone-content">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        <p data-i18n="dropExcelFile">Drop Excel file here</p>
                        <p class="drop-zone-hint" data-i18n="dropOrClickToUpload">or click to upload</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <!-- Main Workflow Section -->
            <div class="workflow-section">
                <h3 data-i18n="workflowTitle">Main Workflow</h3>
                <div class="workflow-controls">
                    <!-- Step 1: Data Input -->
                    <div class="control-group">
                        <span class="step-number">1</span>
                        <input type="file" id="file-input" accept=".xlsx,.xls" style="display: none;">
                        <button onclick="document.getElementById('file-input').click()" class="btn btn-primary" data-i18n="selectFile">Select Excel File</button>
                        <span class="or-text" data-i18n="or">or</span>
                        <button id="load-sample-btn" class="btn" data-i18n="loadSampleData">Load Sample Data</button>
                    </div>
                    
                    <!-- Step 2: View/Edit Data -->
                    <div class="control-group">
                        <span class="step-number">2</span>
                        <button id="toggle-view-btn" class="btn" data-i18n="toggleView" disabled>View/Edit Table</button>
                    </div>
                    
                    <!-- Step 3: Generate Chart -->
                    <div class="control-group">
                        <span class="step-number">3</span>
                        <button id="generate-chart-btn" class="btn btn-primary" data-i18n="generateChart" disabled>Generate Chart</button>
                        
                        <!-- Chart Generation Options -->
                        <div class="chart-options">
                            <div class="option-group">
                                <label data-i18n="startingTeam">起点チーム:</label>
                                <select id="starting-team-select">
                                    <option value="">TOP</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label data-i18n="levelLimit">階層制限:</label>
                                <select id="level-limit-select">
                                    <option value="3" data-i18n="level3">3階層</option>
                                    <option value="4" data-i18n="level4">4階層</option>
                                    <option value="5" data-i18n="level5">5階層</option>
                                    <option value="0" data-i18n="noLimit" selected>制限なし</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label>
                                    <input type="checkbox" id="team-names-only" style="margin-right: 5px;">
                                    <span data-i18n="teamNamesOnly">チーム名のみ</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Step 4: Export -->
                    <div class="control-group">
                        <span class="step-number">4</span>
                        <button id="export-svg-btn" class="btn" data-i18n="exportSVG" disabled>Export SVG</button>
                        <button id="export-png-btn" class="btn" data-i18n="exportPNG" disabled>Export PNG</button>
                        <button id="export-html-btn" class="btn" data-i18n="exportHTML" disabled>Export HTML</button>
                    </div>
                </div>
            </div>
            
            <!-- Additional Functions Section -->
            <div class="additional-section">
                <h3 data-i18n="additionalTitle">Additional Functions</h3>
                <div class="additional-controls">
                    <!-- Language (Top Priority) -->
                    <div class="control-group">
                        <label data-i18n="languageLabel">Language:</label>
                        <select id="language-select">
                            <option value="en">English</option>
                            <option value="ja">日本語</option>
                            <option value="id">Bahasa Indonesia</option>
                        </select>
                    </div>
                    
                    <!-- Other Functions -->
                    <div class="control-group-vertical">
                        <!-- Template Export -->
                        <button id="export-empty-table-btn" class="btn" data-i18n="exportEmptyTable" onclick="exportEmptyTable()">Export Empty Table</button>
                        <button id="export-current-data-btn" class="btn" data-i18n="exportCurrentData" onclick="exportCurrentData()">Export Current Data</button>
                        
                        <!-- Display Settings -->
                        <div class="display-settings">
                            <div class="setting-item">
                                <label data-i18n="fontSize">Font Size:</label>
                                <select id="font-size-select">
                                    <option value="small">Small</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="large">Large</option>
                                </select>
                            </div>
                            
                            <div class="setting-item">
                                <label data-i18n="boxSize">Box Size:</label>
                                <select id="box-size-select">
                                    <option value="small">Small</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="large">Large</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <p>Loading...</p>
        </div>

        <div id="chart-container" class="chart-container">
            <div class="chart-content"></div>
            <div class="chart-controls">
                <button class="chart-control-btn" id="zoom-in-btn">
                    +
                    <span class="tooltip" data-i18n="zoomIn">拡大</span>
                </button>
                <button class="chart-control-btn" id="zoom-out-btn">
                    −
                    <span class="tooltip" data-i18n="zoomOut">縮小</span>
                </button>
                <button class="chart-control-btn" id="zoom-reset-btn">
                    ⌂
                    <span class="tooltip" data-i18n="zoomReset">元のサイズ</span>
                </button>
                <button class="chart-control-btn" id="fullscreen-btn">
                    ⛶
                    <span class="tooltip" data-i18n="fullscreen">フルスクリーン</span>
                </button>
                <div class="chart-control-btn" style="background: rgba(255,255,255,0.7); cursor: default; font-size: 10px; padding: 4px 6px;">
                    Ctrl+wheel
                    <span class="tooltip" data-i18n="ctrlZoom">Ctrl+ホイールでズーム</span>
                </div>
            </div>
        </div>
        <div id="table-container" class="table-container"></div>
    </div>

    <script>
    // Organization Chart Tool v4 with Table Editor - Integrated Version

    // Global namespace
    window.OrgChartTool = window.OrgChartTool || {};

    // 1. Config Module
    (function() {
        'use strict';

        const LANG = {
            en: {
                title: "Organization Chart Tool",
                subtitle: "Automatically generate organization charts from Excel files",
                workflowTitle: "Main Workflow",
                additionalTitle: "Additional Functions",
                loadSampleData: "Load Sample Data",
                selectFile: "Select Excel File",
                generateChart: "Generate Chart",
                toggleView: "View/Edit Table",
                or: "or",
                fontSize: "Font Size:",
                boxSize: "Box Size:",
                exportSVG: "Export SVG",
                exportPNG: "Export PNG",
                exportHTML: "Export HTML",
                exportEmptyTable: "Export Empty Table",
                exportCurrentData: "Export Current Data",
                languageLabel: "Language:",
                startingTeam: "Starting Team:",
                levelLimit: "Level Limit:",
                level3: "3 Levels",
                level4: "4 Levels", 
                level5: "5 Levels",
                noLimit: "No Limit",
                teamNamesOnly: "Team Names Only",
                dropExcelFile: "Drop Excel file here",
                dropOrClickToUpload: "or click to upload",
                appDescriptionTitle: "About This Tool",
                appDescription1: "Create beautiful organization charts from Excel data.",
                appDescription2: "Export empty Excel template, fill in organization data, then upload to generate charts.",
                appDescription3: "Features: Walker's Algorithm layout, interactive editing, multiple export formats.",
                appDescription4: "For graphic editing, export as SVG and edit in PowerPoint, etc.",
                addRow: "Add Row",
                deleteSelected: "Delete Selected",
                applyChanges: "Apply Changes",
                edit: "Edit",
                delete: "Delete",
                level: "Level",
                teamName: "Team Name",
                exactTeamName: "Exact Team Name",
                teamNameComparison: "Team Name Reference",
                teamNameShort: "Chart Display Name",
                teamNameFull: "Full Team Name",
                upperTeam: "Upper Team",
                teamId: "Team ID",
                role: "Role",
                role2ndLang: "Role (2nd Lang)",
                teamBoss: "Team Boss",
                picName: "PIC Name",
                picName2ndLang: "PIC Name (2nd Lang)",
                concurrent: "Concurrent",
                employeeCd: "Employee CD",
                grade: "Grade",
                memo: "Memo",
                borderColor: "Border Color",
                headerBgColor: "Header BG",
                headerTextColor: "Header Text",
                validationErrors: "Validation Errors",
                validationWarnings: "Validation Warnings",
                pleaseFixErrors: "Please fix these errors before applying changes.",
                continueAnyway: "Do you want to continue anyway?",
                noTeamBoss: "has no team boss assigned",
                multipleTeamBoss: "has multiple team bosses. Only one boss per team is recommended",
                multipleTeamBossError: "has multiple team bosses. Only one boss per team is allowed",
                topLevel: "TOP",
                multipleTOP: "teams have \"TOP\" as upper team. Single top-level team is recommended for clear hierarchy",
                // Chart control tooltips
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                zoomReset: "Reset Zoom",
                fullscreen: "Fullscreen",
                exitFullscreen: "Exit Fullscreen",
                ctrlZoom: "Ctrl+wheel to zoom",
                noTOP: "At least one team with upper team \"TOP\" is required"
            },
            ja: {
                title: "組織図作成ツール",
                subtitle: "Excelファイルから組織図を自動生成",
                workflowTitle: "メイン作業フロー",
                additionalTitle: "追加機能",
                loadSampleData: "サンプルデータ読み込み",
                selectFile: "Excelファイル選択",
                generateChart: "組織図生成",
                toggleView: "テーブル表示/編集",
                or: "または",
                fontSize: "フォントサイズ:",
                boxSize: "ボックスサイズ:",
                exportSVG: "SVGエクスポート",
                exportPNG: "PNGエクスポート",
                exportHTML: "HTMLエクスポート",
                exportEmptyTable: "空テーブル出力",
                exportCurrentData: "現在のデータを出力",
                languageLabel: "言語:",
                startingTeam: "起点チーム:",
                levelLimit: "階層制限:",
                level3: "3階層",
                level4: "4階層",
                level5: "5階層",
                noLimit: "制限なし",
                teamNamesOnly: "チーム名のみ",
                dropExcelFile: "Excelファイルをここにドロップ",
                dropOrClickToUpload: "またはクリックでアップロード",
                appDescriptionTitle: "このツールについて",
                appDescription1: "Excelデータから美しい組織図を作成できます。",
                appDescription2: "サンプルを参考に空エクセルを出力して組織情報を入力後、アップロードして組織図を生成してください。",
                appDescription3: "機能：Walker's Algorithm レイアウト、インタラクティブ編集、複数のエクスポート形式。",
                appDescription4: "図形の編集が必要な場合はSVGで出力しPPT等で編集してください。",
                addRow: "行追加",
                deleteSelected: "選択削除",
                applyChanges: "変更適用",
                edit: "編集",
                delete: "削除",
                level: "レベル",
                teamName: "チーム名",
                exactTeamName: "正式チーム名",
                teamNameComparison: "チーム名対照表",
                teamNameShort: "チャート表示名",
                teamNameFull: "正式チーム名",
                upperTeam: "上位チーム",
                teamId: "チームID",
                role: "役割",
                role2ndLang: "役割（第2言語）",
                teamBoss: "チームボス",
                picName: "担当者名",
                picName2ndLang: "担当者名（第2言語）",
                concurrent: "兼務",
                employeeCd: "従業員コード",
                grade: "グレード",
                memo: "メモ",
                borderColor: "枠線色",
                headerBgColor: "ヘッダー背景",
                headerTextColor: "ヘッダー文字",
                validationErrors: "バリデーションエラー",
                validationWarnings: "バリデーション警告",
                pleaseFixErrors: "変更を適用する前に、これらのエラーを修正してください。",
                continueAnyway: "このまま続行しますか？",
                noTeamBoss: "にチームボスが設定されていません",
                multipleTeamBoss: "に複数のチームボスが設定されています。チームごとに1人のボスを推奨します",
                multipleTeamBossError: "に複数のチームボスが設定されています。チームごとに1人のボスのみ許可されます",
                topLevel: "TOP",
                multipleTOP: "個のチームの上位チームが「TOP」に設定されています。明確な階層のため単一の最上位チームを推奨します",
                noTOP: "上位チームが「TOP」のチームが最低1つ必要です",
                // Chart control tooltips
                zoomIn: "拡大",
                zoomOut: "縮小", 
                zoomReset: "元のサイズ",
                fullscreen: "フルスクリーン",
                exitFullscreen: "フルスクリーン終了",
                ctrlZoom: "Ctrl+ホイールでズーム"
            },
            id: {
                title: "Alat Bagan Organisasi",
                subtitle: "Otomatis membuat bagan organisasi dari file Excel",
                workflowTitle: "Alur Kerja Utama",
                additionalTitle: "Fungsi Tambahan",
                loadSampleData: "Muat Data Sampel",
                selectFile: "Pilih File Excel",
                generateChart: "Buat Bagan",
                toggleView: "Lihat/Edit Tabel",
                or: "atau",
                fontSize: "Ukuran Font:",
                boxSize: "Ukuran Kotak:",
                exportSVG: "Ekspor SVG",
                exportPNG: "Ekspor PNG",
                exportHTML: "Ekspor HTML",
                exportEmptyTable: "Ekspor Tabel Kosong", 
                exportCurrentData: "Ekspor Data Saat Ini",
                languageLabel: "Bahasa:",
                startingTeam: "Tim Awal:",
                levelLimit: "Batas Level:",
                level3: "3 Level",
                level4: "4 Level",
                level5: "5 Level",
                noLimit: "Tanpa Batas",
                teamNamesOnly: "Nama Tim Saja",
                dropExcelFile: "Jatuhkan file Excel di sini",
                dropOrClickToUpload: "atau klik untuk mengunggah",
                appDescriptionTitle: "Tentang Tool Ini",
                appDescription1: "Buat bagan organisasi yang indah dari data Excel.",
                appDescription2: "Unggah file Excel Anda atau gunakan data sampel untuk memulai.",
                appDescription3: "Fitur: Layout Walker's Algorithm, editing interaktif, berbagai format ekspor.",
                appDescription4: "Untuk editing grafis, ekspor sebagai SVG dan edit di PowerPoint, dll.",
                addRow: "Tambah Baris",
                deleteSelected: "Hapus Terpilih",
                applyChanges: "Terapkan Perubahan",
                edit: "Edit",
                delete: "Hapus",
                level: "Level",
                teamName: "Nama Tim",
                exactTeamName: "Nama Tim Tepat",
                teamNameComparison: "Referensi Nama Tim",
                teamNameShort: "Nama Tampilan Chart",
                teamNameFull: "Nama Tim Lengkap",
                upperTeam: "Tim Atas",
                teamId: "ID Tim",
                role: "Peran",
                role2ndLang: "Peran (Bahasa ke-2)",
                teamBoss: "Bos Tim",
                picName: "Nama PIC",
                picName2ndLang: "Nama PIC (Bahasa ke-2)",
                concurrent: "Bersamaan",
                employeeCd: "Kode Karyawan",
                grade: "Grade",
                memo: "Memo",
                borderColor: "Warna Batas",
                headerBgColor: "BG Header",
                headerTextColor: "Teks Header",
                validationErrors: "Kesalahan Validasi",
                validationWarnings: "Peringatan Validasi",
                pleaseFixErrors: "Silakan perbaiki kesalahan ini sebelum menerapkan perubahan.",
                continueAnyway: "Apakah Anda ingin melanjutkan?",
                noTeamBoss: "tidak memiliki bos tim",
                multipleTeamBoss: "memiliki beberapa bos tim. Satu bos per tim direkomendasikan",
                multipleTeamBossError: "memiliki beberapa bos tim. Hanya satu bos per tim yang diizinkan",
                topLevel: "TOP",
                multipleTOP: "tim memiliki \"TOP\" sebagai tim atas. Tim tingkat atas tunggal direkomendasikan untuk hierarki yang jelas",
                noTOP: "Setidaknya satu tim dengan tim atas \"TOP\" diperlukan",
                // Chart control tooltips
                zoomIn: "Perbesar",
                zoomOut: "Perkecil",
                zoomReset: "Reset Zoom",
                fullscreen: "Layar Penuh", 
                exitFullscreen: "Keluar Layar Penuh",
                ctrlZoom: "Ctrl+wheel untuk zoom"
            }
        };

        const CORRECTED_SAMPLE_DATA = [
            // Level 1: CEO
            [1, "Headquarters", "Corporate Headquarters", "TOP", "", "President & CEO", "代表取締役社長", true, "Robert Johnson", "ロバート・ジョンソン", "", "001", "President & CEO", "", "#1a237e", "#e8eaf6", "#ffffff"],
            
            // Level 2: Directors & Executive Officers
            [2, "Manufacturing", "Manufacturing Division", "Headquarters", "", "Manufacturing Director", "製造担当取締役", true, "Sarah Williams", "サラ・ウィリアムズ", "", "101", "Manufacturing Director", "", "#4caf50", "#f1f8e9", "#000000"],
            [2, "Sales", "Sales Division", "Headquarters", "", "Sales Director", "営業担当取締役", true, "Michael Chen", "マイケル・チェン", "", "201", "Sales Director", "", "#ff9800", "#fff3e0", "#000000"],
            [2, "R&D", "Research & Development Division", "Headquarters", "", "R&D Director", "開発担当取締役", true, "Jennifer Davis", "ジェニファー・デイビス", "", "301", "R&D Director", "", "#e91e63", "#fce4ec", "#000000"],
            [2, "Administration", "Administration Division", "Headquarters", "", "Administration Director", "管理担当取締役", true, "David Martinez", "デビッド・マルティネス", "", "401", "Administration Director", "", "#9c27b0", "#f3e5f5", "#000000"],
            [2, "Quality Assurance", "Quality Assurance Division", "Headquarters", "", "Quality Assurance Director", "品質保証担当取締役", true, "Lisa Anderson", "リサ・アンダーソン", "", "501", "Quality Assurance Director", "", "#2196f3", "#e3f2fd", "#000000"],
            
            // Level 3: Department Managers
            [3, "Plant 1", "Manufacturing Plant 1", "Manufacturing", "", "Plant 1 Manager", "第一工場長", true, "James Thompson", "ジェームス・トンプソン", "", "1001", "Plant Manager", "", "#4caf50", "#f1f8e9", "#000000"],
            [3, "Plant 2", "Manufacturing Plant 2", "Manufacturing", "", "Plant 2 Manager", "第二工場長", true, "Amanda Rodriguez", "アマンダ・ロドリゲス", "", "1002", "Plant Manager", "", "#4caf50", "#f1f8e9", "#000000"],
            [3, "Plant 3", "Manufacturing Plant 3", "Manufacturing", "", "Plant 3 Manager", "第三工場長", true, "Christopher Lee", "クリストファー・リー", "", "1003", "Plant Manager", "", "#4caf50", "#f1f8e9", "#000000"],
            [3, "Production Engineering", "Production Engineering Dept", "Manufacturing", "", "Production Engineering Manager", "生産技術部長", true, "Maria Garcia", "マリア・ガルシア", "", "1101", "Production Engineering Manager", "", "#4caf50", "#f1f8e9", "#000000"],
            [3, "Domestic Sales", "Domestic Sales Department", "Sales", "", "Domestic Sales Manager", "国内営業部長", true, "Kevin Brown", "ケビン・ブラウン", "", "2001", "Domestic Sales Manager", "", "#ff9800", "#fff3e0", "#000000"],
            [3, "International Sales", "International Sales Dept", "Sales", "", "International Sales Manager", "海外営業部長", true, "Rachel Martin", "レイチェル・マーティン", "", "2002", "International Sales Manager", "", "#ff9800", "#fff3e0", "#000000"],
            [3, "Marketing", "Marketing Department", "Sales", "", "Marketing Manager", "マーケティング部長", true, "Jason Wilson", "ジェイソン・ウィルソン", "", "2101", "Marketing Manager", "", "#ff9800", "#fff3e0", "#000000"],
            [3, "Research & Development", "R&D Department", "R&D", "", "R&D Manager", "研究開発部長", true, "Emily Taylor", "エミリー・テイラー", "", "3001", "R&D Manager", "", "#e91e63", "#fce4ec", "#000000"],
            [3, "Design", "Design Department", "R&D", "", "Design Manager", "設計部長", true, "Daniel Moore", "ダニエル・ムーア", "", "3101", "Design Manager", "", "#e91e63", "#fce4ec", "#000000"],
            [3, "General Affairs", "General Affairs Department", "Administration", "", "General Affairs Manager", "総務部長", true, "Ashley Miller", "アシュリー・ミラー", "", "4001", "General Affairs Manager", "", "#9c27b0", "#f3e5f5", "#000000"],
            [3, "Human Resources", "HR Department", "Administration", "", "HR Manager", "人事部長", true, "Brian Clark", "ブライアン・クラーク", "", "4101", "HR Manager", "", "#9c27b0", "#f3e5f5", "#000000"],
            [3, "Accounting", "Accounting Department", "Administration", "", "Accounting Manager", "経理部長", true, "Nicole White", "ニコール・ホワイト", "", "4201", "Accounting Manager", "", "#9c27b0", "#f3e5f5", "#000000"],
            [3, "Information Systems", "IT Department", "Administration", "", "IT Manager", "情報システム部長", true, "Ryan Lewis", "ライアン・ルイス", "", "4301", "IT Manager", "", "#9c27b0", "#f3e5f5", "#000000"],
            [3, "Quality Control", "Quality Control Department", "Quality Assurance", "", "Quality Control Manager", "品質管理部長", true, "Stephanie Walker", "ステファニー・ウォーカー", "", "5001", "Quality Control Manager", "", "#2196f3", "#e3f2fd", "#000000"],
            [3, "Quality Assurance", "Quality Assurance Department", "Headquarters", "", "Quality Assurance Manager", "品質保証部長", false, "Mark Harris", "マーク・ハリス", "", "5101", "Quality Assurance Manager", "", "#2196f3", "#e3f2fd", "#000000"],
            
            // Level 4: Section Chiefs
            [4, "Assembly Section", "Assembly Section", "Plant 1", "", "Assembly Section Chief", "組立課長", true, "Andrew Young", "アンドリュー・ヤング", "", "10001", "Assembly Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Machining Section", "Machining Section", "Plant 1", "", "Machining Section Chief", "機械加工課長", true, "Michelle King", "ミシェル・キング", "", "10002", "Machining Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Welding Section", "Welding Section", "Plant 2", "", "Welding Section Chief", "溶接課長", true, "Angela Green", "アンジェラ・グリーン", "", "10201", "Welding Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Inspection Section", "Inspection Section", "Plant 2", "", "Inspection Section Chief", "検査課長", true, "Rebecca Baker", "レベッカ・ベイカー", "", "10203", "Inspection Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Molding Section", "Molding Section", "Plant 3", "", "Molding Section Chief", "成形課長", true, "Timothy Nelson", "ティモシー・ネルソン", "", "10301", "Molding Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Die Section", "Die Section", "Plant 3", "", "Die Section Chief", "金型課長", true, "Catherine Hall", "キャサリン・ホール", "", "10302", "Die Section Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Process Control", "Process Control Section", "Production Engineering", "", "Process Control Chief", "工程管理課長", true, "Joshua Allen", "ジョシュア・アレン", "", "11001", "Process Control Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Maintenance", "Maintenance Section", "Production Engineering", "", "Maintenance Chief", "設備保全課長", true, "Samantha Scott", "サマンサ・スコット", "", "11002", "Maintenance Chief", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "East Region Sales", "East Region Sales Section", "Domestic Sales", "", "East Region Sales Chief", "東日本営業課長", true, "Benjamin Turner", "ベンジャミン・ターナー", "", "20001", "East Region Sales Chief", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Asia Sales", "Asia Sales Section", "International Sales", "", "Asia Sales Chief", "アジア営業課長", true, "Gregory Campbell", "グレゴリー・キャンベル", "", "20101", "Asia Sales Chief", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Europe & Americas", "Europe & Americas Sales", "International Sales", "", "Europe & Americas Sales Chief", "欧米営業課長", true, "Victoria Parker", "ビクトリア・パーカー", "", "20102", "Europe & Americas Sales Chief", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Product Planning", "Product Planning Section", "Marketing", "", "Product Planning Chief", "商品企画課長", true, "Nathan Evans", "ネイサン・エバンス", "", "21001", "Product Planning Chief", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Materials Research", "Materials Research Section", "Research & Development", "", "Materials Research Chief", "材料研究課長", true, "Heather Edwards", "ヘザー・エドワーズ", "", "30001", "Materials Research Chief", "", "#f06292", "#fce4ec", "#000000"],
            [4, "Mechanical Design", "Mechanical Design Section", "Design", "", "Mechanical Design Chief", "機械設計課長", true, "Christina Stewart", "クリスティーナ・スチュワート", "", "31001", "Mechanical Design Chief", "", "#f06292", "#fce4ec", "#000000"],
            [4, "Electrical Design", "Electrical Design Section", "Design", "", "Electrical Design Chief", "電気設計課長", true, "Adam Sanchez", "アダム・サンチェス", "", "31002", "Electrical Design Chief", "", "#f06292", "#fce4ec", "#000000"],
            [4, "General Affairs", "General Affairs Section", "Administration", "", "General Affairs Chief", "総務課長", false, "Melissa Morris", "メリッサ・モリス", "", "40001", "General Affairs Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "Legal Affairs", "Legal Affairs Section", "General Affairs", "", "Legal Affairs Chief", "法務課長", true, "Eric Rogers", "エリック・ロジャース", "", "40002", "Legal Affairs Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "HR Operations", "HR Operations Section", "Human Resources", "", "HR Operations Chief", "人事課長", true, "Tiffany Reed", "ティファニー・リード", "", "41001", "HR Operations Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "Labor Management", "Labor Management Section", "Human Resources", "", "Labor Management Chief", "労務課長", true, "Richard Cook", "リチャード・クック", "", "41002", "Labor Management Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "Accounting", "Accounting Section", "Administration", "", "Accounting Chief", "経理課長", false, "Karen Morgan", "カレン・モーガン", "", "42001", "Accounting Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "System Development", "System Development Section", "Information Systems", "", "System Development Chief", "システム開発課長", true, "Andrea Rivera", "アンドリア・リベラ", "", "43001", "System Development Chief", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "QC Operations", "QC Operations Section", "Quality Control", "", "QC Operations Chief", "品質管理課長", true, "Keith Cooper", "キース・クーパー", "", "50001", "QC Operations Chief", "", "#42a5f5", "#e3f2fd", "#000000"],
            [4, "QA Operations", "QA Operations Section", "Quality Assurance", "", "QA Operations Chief", "品質保証課長", true, "Denise Richardson", "デニス・リチャードソン", "", "51001", "QA Operations Chief", "", "#42a5f5", "#e3f2fd", "#000000"],
            
            // Level 5: Supervisors
            [5, "Assembly Team 1", "Assembly Team 1", "Assembly Section", "", "Assembly Supervisor", "組立係長", true, "Tony Watson", "トニー・ワトソン", "", "100011", "Assembly Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Assembly Team 2", "Assembly Team 2", "Assembly Section", "", "Assembly Supervisor", "組立係長", true, "Gloria Cox", "グロリア・コックス", "", "100012", "Assembly Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Lathe Team", "Lathe Team", "Machining Section", "", "Lathe Supervisor", "旋盤係長", true, "Carl Ward", "カール・ワード", "", "100021", "Lathe Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Milling Team", "Milling Team", "Machining Section", "", "Milling Supervisor", "フライス係長", true, "Diane Torres", "ダイアン・トーレス", "", "100022", "Milling Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Auto Painting", "Auto Painting Team", "Painting Section", "", "Auto Painting Supervisor", "塗装係長", true, "Gary Peterson", "ゲイリー・ピーターソン", "", "100031", "Auto Painting Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Manual Painting", "Manual Painting Team", "Painting Section", "", "Manual Painting Supervisor", "塗装係長", true, "Julie Gray", "ジュリー・グレイ", "", "100032", "Manual Painting Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Arc Welding", "Arc Welding Team", "Welding Section", "", "Arc Welding Supervisor", "溶接係長", true, "Harold Ramirez", "ハロルド・ラミレス", "", "102011", "Arc Welding Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Spot Welding", "Spot Welding Team", "Welding Section", "", "Spot Welding Supervisor", "溶接係長", true, "Frances James", "フランシス・ジェームス", "", "102012", "Spot Welding Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Large Press", "Large Press Team", "Press Section", "", "Large Press Supervisor", "プレス係長", true, "Wayne Watson", "ウェイン・ワトソン", "", "102021", "Large Press Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Small Press", "Small Press Team", "Press Section", "", "Small Press Supervisor", "プレス係長", true, "Marie Brooks", "マリー・ブルックス", "", "102022", "Small Press Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Incoming Inspection", "Incoming Inspection Team", "Inspection Section", "", "Incoming Inspection Supervisor", "検査係長", true, "Arthur Kelly", "アーサー・ケリー", "", "102031", "Incoming Inspection Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            [5, "Final Inspection", "Final Inspection Team", "Inspection Section", "", "Final Inspection Supervisor", "検査係長", true, "Cheryl Sanders", "シェリル・サンダース", "", "102032", "Final Inspection Supervisor", "", "#81c784", "#e8f5e8", "#000000"],
            
            // Level 6: Workers (Sample)
            [6, "Assembly Line A", "Assembly Line A", "Assembly Team 1", "", "Assembly Worker", "組立作業員", false, "Frank Price", "フランク・プライス", "", "1000111", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Assembly Line A", "Assembly Line A", "Assembly Team 1", "", "Assembly Worker", "組立作業員", false, "Janet Perry", "ジャネット・ペリー", "", "1000112", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Assembly Line A", "Assembly Line A", "Assembly Team 1", "", "Assembly Worker", "組立作業員", false, "Ralph Bennett", "ラルフ・ベネット", "", "1000113", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Assembly Line B", "Assembly Line B", "Assembly Team 2", "", "Assembly Worker", "組立作業員", false, "Donna Powell", "ドナ・パウエル", "", "1000121", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Assembly Line B", "Assembly Line B", "Assembly Team 2", "", "Assembly Worker", "組立作業員", false, "Jerry Long", "ジェリー・ロング", "", "1000122", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Assembly Line B", "Assembly Line B", "Assembly Team 2", "", "Assembly Worker", "組立作業員", false, "Rose Hughes", "ローズ・ヒューズ", "", "1000123", "Assembly Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Lathe Unit 1", "Lathe Unit 1", "Lathe Team", "", "Lathe Operator", "旋盤工", false, "Eugene Foster", "ユージーン・フォスター", "", "1000211", "Lathe Operator", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Lathe Unit 1", "Lathe Unit 1", "Lathe Team", "", "Lathe Operator", "旋盤工", false, "Norma Russell", "ノーマ・ラッセル", "", "1000212", "Lathe Operator", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Lathe Unit 2", "Lathe Unit 2", "Lathe Team", "", "Lathe Operator", "旋盤工", false, "Louis Griffin", "ルイス・グリフィン", "", "1000213", "Lathe Operator", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Milling Unit 1", "Milling Unit 1", "Milling Team", "", "Milling Operator", "フライス工", false, "Judy Diaz", "ジュディ・ディアス", "", "1000221", "Milling Operator", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Milling Unit 1", "Milling Unit 1", "Milling Team", "", "Milling Operator", "フライス工", false, "Bobby Hayes", "ボビー・ヘイズ", "", "1000222", "Milling Operator", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Paint Line 1", "Paint Line 1", "Auto Painting", "", "Painting Worker", "塗装工", false, "Ruby Myers", "ルビー・マイヤーズ", "", "1000311", "Painting Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Paint Line 1", "Paint Line 1", "Auto Painting", "", "Painting Worker", "塗装工", false, "Philip Ford", "フィリップ・フォード", "", "1000312", "Painting Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            [6, "Paint Line 2", "Paint Line 2", "Manual Painting", "", "Painting Worker", "塗装工", false, "Annie Hamilton", "アニー・ハミルトン", "", "1000321", "Painting Worker", "", "#a5d6a7", "#f1f8e9", "#000000"],
            
            // Concurrent bosses (兼務者) - upper level managers also managing lower level sections
            [4, "Painting Section", "Painting Section", "Plant 1", "", "Painting Section Chief", "塗装課長", true, "James Thompson", "ジェームス・トンプソン", "Y", "10003", "Plant Manager (Concurrent)", "兼務・第一工場長", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Press Section", "Press Section", "Plant 2", "", "Press Section Chief", "プレス課長", true, "Amanda Rodriguez", "アマンダ・ロドリゲス", "Y", "10202", "Plant Manager (Concurrent)", "兼務・第二工場長", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "West Region Sales", "West Region Sales Section", "Domestic Sales", "", "West Region Sales Chief", "西日本営業課長", true, "Kevin Brown", "ケビン・ブラウン", "Y", "20002", "Domestic Sales Manager (Concurrent)", "兼務・国内営業部長", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Product Development", "Product Development Section", "Research & Development", "", "Product Development Chief", "製品開発課長", true, "Emily Taylor", "エミリー・テイラー", "Y", "30002", "R&D Manager (Concurrent)", "兼務・研究開発部長", "#f06292", "#fce4ec", "#000000"],
            [4, "Finance", "Finance Section", "Accounting", "", "Finance Chief", "財務課長", true, "Nicole White", "ニコール・ホワイト", "Y", "42002", "Accounting Manager (Concurrent)", "兼務・経理部長", "#ba68c8", "#f3e5f5", "#000000"],
            
            // Non-boss team members - in various departments
            [4, "Assembly Section", "Assembly Section", "Plant 1", "", "Senior Assembly Engineer", "主任組立技術者", false, "Thomas Anderson", "トーマス・アンダーソン", "", "10001A", "Senior Assembly Engineer", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Machining Section", "Machining Section", "Plant 1", "", "Senior Machining Engineer", "主任機械加工技術者", false, "Linda Thompson", "リンダ・トンプソン", "", "10002A", "Senior Machining Engineer", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "Welding Section", "Welding Section", "Plant 2", "", "Senior Welding Engineer", "主任溶接技術者", false, "Robert Kim", "ロバート・キム", "", "10201A", "Senior Welding Engineer", "", "#66bb6a", "#e8f5e8", "#000000"],
            [4, "East Region Sales", "East Region Sales Section", "Domestic Sales", "", "Senior Sales Representative", "主任営業", false, "Jennifer Walsh", "ジェニファー・ウォルシュ", "", "20001A", "Senior Sales Representative", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Asia Sales", "Asia Sales Section", "International Sales", "", "Senior Account Manager", "主任アカウントマネージャー", false, "Michael Tanaka", "マイケル・田中", "", "20101A", "Senior Account Manager", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Materials Research", "Materials Research Section", "Research & Development", "", "Senior Research Engineer", "主任研究員", false, "Sarah Johnson", "サラ・ジョンソン", "", "30001A", "Senior Research Engineer", "", "#f06292", "#fce4ec", "#000000"],
            [4, "Mechanical Design", "Mechanical Design Section", "Design", "", "Senior Design Engineer", "主任設計者", false, "David Lee", "デビッド・リー", "", "31001A", "Senior Design Engineer", "", "#f06292", "#fce4ec", "#000000"],
            [4, "HR Operations", "HR Operations Section", "Human Resources", "", "Senior HR Specialist", "主任人事担当", false, "Jessica Martinez", "ジェシカ・マルティネス", "", "41001A", "Senior HR Specialist", "", "#ba68c8", "#f3e5f5", "#000000"],
            [4, "QC Operations", "QC Operations Section", "Quality Control", "", "Senior QC Inspector", "主任品質管理", false, "William Chen", "ウィリアム・チェン", "", "50001A", "Senior QC Inspector", "", "#42a5f5", "#e3f2fd", "#000000"],
            
            // Advisors - typically for foreign companies supporting local team leaders
            [4, "Asia Sales", "Asia Sales Section", "International Sales", "", "Regional Sales Advisor", "地域営業アドバイザー", false, "John Smith", "ジョン・スミス", "", "20101ADV", "Regional Sales Advisor", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Europe & Americas", "Europe & Americas Sales", "International Sales", "", "International Sales Advisor", "海外営業アドバイザー", false, "Emma Johnson", "エマ・ジョンソン", "", "20102ADV", "International Sales Advisor", "", "#ffb74d", "#fff8e1", "#000000"],
            [4, "Materials Research", "Materials Research Section", "Research & Development", "", "Technical Advisor", "技術アドバイザー", false, "Dr. Hans Mueller", "ハンス・ミュラー博士", "", "30001ADV", "Technical Advisor", "", "#f06292", "#fce4ec", "#000000"],
            [4, "System Development", "System Development Section", "Information Systems", "Quality Assurance", "IT Strategy Advisor", "IT戦略アドバイザー", false, "Steve Wilson", "スティーブ・ウィルソン", "Y", "43001ADV", "IT Strategy Advisor", "兼務・品質保証課", "#ba68c8", "#f3e5f5", "#000000"]
        ];

        let CURRENT_LANG = localStorage.getItem('organizationChartLang') || 'en';

        function t(key, params = {}) {
            const keys = key.split('.');
            let value = LANG[CURRENT_LANG];
            
            for (const k of keys) {
                value = value?.[k];
                if (!value) break;
            }
            
            if (typeof value === 'string') {
                return value.replace(/\{\{(\w+)\}\}/g, (match, param) => params[param] || match);
            }
            
            return key;
        }

        const LanguageManager = {
            getCurrentLanguage() {
                return CURRENT_LANG;
            },
            
            setLanguage(langCode) {
                if (LANG[langCode]) {
                    CURRENT_LANG = langCode;
                    localStorage.setItem('organizationChartLang', langCode);
                    this.updatePageContent();
                }
            },
            
            updatePageContent() {
                document.title = t('title');
                
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    const translated = t(key);
                    
                    if (element.tagName === 'INPUT' && (element.type === 'button' || element.type === 'submit')) {
                        element.value = translated;
                    } else {
                        element.textContent = translated;
                    }
                });
                
                const languageSelect = document.getElementById('language-select');
                if (languageSelect) {
                    languageSelect.value = CURRENT_LANG;
                }
                
                // Update table if it exists and is active
                if (window.OrgChartTool && window.OrgChartTool.App && window.OrgChartTool.App.tableEditor) {
                    const tableEditor = window.OrgChartTool.App.tableEditor;
                    if (tableEditor.isActive()) {
                        tableEditor.render(tableEditor.getTableDataAsRaw());
                    }
                }
            },
            
            initialize() {
                this.updatePageContent();
            }
        };

        const CONFIG = {
            DEFAULTS: {
                BOX_SIZES: {
                    small: { width: '110px', height: '128px', spacingX: '129px', spacingY: '144px' },
                    medium: { width: '138px', height: '160px', spacingX: '161px', spacingY: '180px' },
                    large: { width: '166px', height: '192px', spacingX: '193px', spacingY: '216px' }
                },
                FONT_SIZES: {
                    small: { size: '10px', headerSize: '11px' },
                    medium: { size: '12px', headerSize: '13px' },
                    large: { size: '14px', headerSize: '15px' }
                }
            }
        };

        window.OrgChartTool.Config = {
            LANG,
            CURRENT_LANG,
            t,
            LanguageManager,
            CONFIG,
            SAMPLE_DATA: CORRECTED_SAMPLE_DATA
        };

    })();

    // 2. Data Processor Module
    (function() {
        'use strict';

        class DataProcessor {
            constructor() {
                this.rawData = [];
                this.processedData = {
                    organizations: new Map(),
                    hierarchy: new Map(),
                    managers: new Map(),
                    advisors: new Map(),
                    dataOrder: new Map()
                };
                this.callNameMapping = new Map();
                this.errors = [];
                this.isProcessed = false;
                
                this.COLUMN_MAPPING = {
                    level: 0, teamName: 1, exactTeamName: 2, upperTeam: 3, teamId: 4,
                    role: 5, role2ndLang: 6, teamBoss: 7, picName: 8, picName2ndLang: 9,
                    concurrent: 10, employeeCd: 11, grade: 12, memo: 13,
                    borderColor: 14, headerBgColor: 15, headerTextColor: 16
                };
            }

            async processExcelFile(file) {
                try {
                    let arrayBuffer;
                    
                    // Try modern approach first
                    if (file.arrayBuffer) {
                        arrayBuffer = await file.arrayBuffer();
                    } else {
                        // Fallback for older browsers
                        arrayBuffer = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(file);
                        });
                    }
                    
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    
                    const sheetNames = workbook.SheetNames;
                    if (sheetNames.length === 0) {
                        throw new Error('No worksheets found');
                    }
                    
                    const worksheet = workbook.Sheets[sheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (data.length < 2) {
                        throw new Error('Insufficient data');
                    }
                    
                    this.rawData = data.slice(1).filter(row => 
                        row && row.length > 0 && row.some(cell => cell !== null && cell !== undefined && cell !== '')
                    );
                    
                    return this.rawData;
                } catch (error) {
                    throw new Error(`Failed to process Excel file: ${error.message}`);
                }
            }

            loadSampleData() {
                this.rawData = [...window.OrgChartTool.Config.SAMPLE_DATA];
                this.processData();
            }

            processData() {
                try {
                    this.processedData = {
                        organizations: new Map(),
                        hierarchy: new Map(),
                        managers: new Map(),
                        advisors: new Map(),
                        dataOrder: new Map()
                    };
                    this.callNameMapping.clear();
                    this.errors = [];
                    this.isProcessed = false;
                    
                    if (!this.rawData || this.rawData.length === 0) {
                        throw new Error('No data to process');
                    }
                    
                    this.cleanData();
                    this.buildTeamNameMapping();
                    this.buildOrganizationData();
                    this.buildHierarchy();
                    this.processManagersAndAdvisors();
                    this.validateData();
                    
                    this.isProcessed = true;
                    return Array.from(this.processedData.organizations.values());
                } catch (error) {
                    this.errors.push(`Data processing failed: ${error.message}`);
                    throw error;
                }
            }

            cleanData() {
                const cleanedData = [];
                let skippedRows = 0;
                
                this.rawData.forEach((row, index) => {
                    try {
                        const level = row[this.COLUMN_MAPPING.level];
                        const teamName = row[this.COLUMN_MAPPING.teamName];
                        const picName = row[this.COLUMN_MAPPING.picName];
                        const role = row[this.COLUMN_MAPPING.role];
                        
                        if (!level || !teamName || !picName || !role) {
                            skippedRows++;
                            return;
                        }
                        
                        const cleanedRow = [...row];
                        cleanedRow[this.COLUMN_MAPPING.level] = parseInt(level) || 1;
                        
                        ['teamName', 'exactTeamName', 'upperTeam', 'teamId',
                         'role', 'role2ndLang', 'picName', 'picName2ndLang',
                         'concurrent', 'employeeCd', 'grade', 'memo'].forEach(field => {
                            const index = this.COLUMN_MAPPING[field];
                            if (cleanedRow[index]) {
                                cleanedRow[index] = cleanedRow[index].toString().trim();
                            }
                        });
                        
                        const teamBoss = row[this.COLUMN_MAPPING.teamBoss];
                        cleanedRow[this.COLUMN_MAPPING.teamBoss] = 
                            (teamBoss && ['Y', 'y', 'Yes', 'yes', 'true', '1', true].includes(teamBoss)) ? 'Y' : 'N';
                        
                        cleanedData.push(cleanedRow);
                    } catch (error) {
                        skippedRows++;
                    }
                });
                
                this.rawData = cleanedData;
            }

            buildTeamNameMapping() {
                this.callNameMapping.clear();
                
                this.rawData.forEach(row => {
                    const teamName = row[this.COLUMN_MAPPING.teamName];
                    const exactTeamName = row[this.COLUMN_MAPPING.exactTeamName] || teamName;
                    
                    if (teamName && exactTeamName) {
                        this.callNameMapping.set(teamName, exactTeamName);
                    }
                });
            }

            buildOrganizationData() {
                this.rawData.forEach((row, index) => {
                    try {
                        const teamName = row[this.COLUMN_MAPPING.teamName];
                        const level = row[this.COLUMN_MAPPING.level];
                        const upperTeam = row[this.COLUMN_MAPPING.upperTeam];
                        const exactTeamName = row[this.COLUMN_MAPPING.exactTeamName] || teamName;
                        
                        const parent = (upperTeam === 'N/A' || !upperTeam || upperTeam.trim() === '' || upperTeam.trim().toUpperCase() === 'TOP') ? null : upperTeam;
                        
                        if (!this.processedData.organizations.has(teamName)) {
                            const orgData = {
                                id: teamName,
                                name: teamName,
                                teamName: teamName,
                                exactName: exactTeamName,
                                exactTeamName: exactTeamName,
                                level: level,
                                parent: parent,
                                upperTeam: parent,
                                managers: [],
                                advisors: [],
                                teamMembers: [], // Add team members array
                                colors: {
                                    borderColor: row[this.COLUMN_MAPPING.borderColor] || '',
                                    headerBgColor: row[this.COLUMN_MAPPING.headerBgColor] || '',
                                    headerTextColor: row[this.COLUMN_MAPPING.headerTextColor] || ''
                                },
                                teamId: row[this.COLUMN_MAPPING.teamId] || '',
                                dataOrder: index
                            };
                            
                            this.processedData.organizations.set(teamName, orgData);
                            this.processedData.dataOrder.set(teamName, index);
                        }
                        
                        const picName = row[this.COLUMN_MAPPING.picName];
                        const role = row[this.COLUMN_MAPPING.role];
                        const teamBoss = row[this.COLUMN_MAPPING.teamBoss] === 'Y';
                        
                        const personData = {
                            name: picName,
                            name2ndLang: row[this.COLUMN_MAPPING.picName2ndLang] || '',
                            role: role,
                            role2ndLang: row[this.COLUMN_MAPPING.role2ndLang] || '',
                            isTeamBoss: teamBoss,
                            concurrent: row[this.COLUMN_MAPPING.concurrent] || '',
                            employeeCd: row[this.COLUMN_MAPPING.employeeCd] || '',
                            grade: row[this.COLUMN_MAPPING.grade] || '',
                            memo: row[this.COLUMN_MAPPING.memo] || ''
                        };
                        
                        const orgData = this.processedData.organizations.get(teamName);
                        
                        if (teamBoss) {
                            orgData.picName = picName;
                            orgData.picName2ndLang = personData.name2ndLang;
                            orgData.role = role;
                            orgData.role2ndLang = personData.role2ndLang;
                            orgData.concurrent = row[this.COLUMN_MAPPING.concurrent] || '';
                            
                            if (row[this.COLUMN_MAPPING.borderColor]) {
                                orgData.borderColor = row[this.COLUMN_MAPPING.borderColor];
                            }
                            if (row[this.COLUMN_MAPPING.headerBgColor]) {
                                orgData.headerBgColor = row[this.COLUMN_MAPPING.headerBgColor];
                            }
                            if (row[this.COLUMN_MAPPING.headerTextColor]) {
                                orgData.headerTextColor = row[this.COLUMN_MAPPING.headerTextColor];
                            }
                        } else {
                            // Add to team members if not a boss
                            orgData.teamMembers.push({
                                picName: picName,
                                role: role,
                                concurrent: row[this.COLUMN_MAPPING.concurrent] || ''
                            });
                        }
                        
                        orgData.managers.push(personData);
                        
                    } catch (error) {
                        this.errors.push(`Row ${index + 1}: ${error.message}`);
                    }
                });
            }

            buildHierarchy() {
                this.processedData.hierarchy.clear();
                
                this.processedData.organizations.forEach((orgData, orgName) => {
                    const parent = orgData.parent;
                    
                    if (parent && this.processedData.organizations.has(parent)) {
                        if (!this.processedData.hierarchy.has(parent)) {
                            this.processedData.hierarchy.set(parent, []);
                        }
                        this.processedData.hierarchy.get(parent).push(orgName);
                    }
                });
                
                this.processedData.hierarchy.forEach((children, parent) => {
                    children.sort((a, b) => {
                        const orderA = this.processedData.dataOrder.get(a) || 0;
                        const orderB = this.processedData.dataOrder.get(b) || 0;
                        return orderA - orderB;
                    });
                });
            }

            processManagersAndAdvisors() {
                this.processedData.managers.clear();
                this.processedData.advisors.clear();
                
                this.processedData.organizations.forEach((orgData, orgName) => {
                    if (orgData.managers.length > 0) {
                        this.processedData.managers.set(orgName, orgData.managers);
                    }
                    if (orgData.advisors.length > 0) {
                        this.processedData.advisors.set(orgName, orgData.advisors);
                    }
                });
            }

            validateData() {
                const validationErrors = [];
                let rootCount = 0;
                
                this.processedData.organizations.forEach((orgData, orgName) => {
                    if (!orgData.name) {
                        validationErrors.push(`Organization ${orgName}: Team Name is required`);
                    }
                    
                    if (orgData.level < 1 || orgData.level > 10) {
                        validationErrors.push(`Organization ${orgName}: Level must be between 1-10`);
                    }
                    
                    if (orgData.managers.length === 0 && orgData.advisors.length === 0) {
                        validationErrors.push(`Organization ${orgName}: At least one person is required`);
                    }
                    
                    if (orgData.parent && !this.processedData.organizations.has(orgData.parent)) {
                        validationErrors.push(`Organization ${orgName}: Parent organization "${orgData.parent}" not found`);
                    }
                    
                    if (!orgData.parent) {
                        rootCount++;
                    }
                });
                
                if (rootCount === 0) {
                    validationErrors.push('No root organization found');
                } else if (rootCount > 1) {
                    validationErrors.push(`Multiple root organizations found: ${rootCount}`);
                }
                
                this.errors.push(...validationErrors);
            }

            updateFromTableData(tableData) {
                // Convert table data back to raw data format
                this.rawData = tableData.map(row => {
                    const rawRow = new Array(17).fill('');
                    Object.keys(this.COLUMN_MAPPING).forEach(key => {
                        const index = this.COLUMN_MAPPING[key];
                        rawRow[index] = row[key] || '';
                    });
                    return rawRow;
                });
                
                // Reprocess the data
                this.processData();
            }

            getProcessedData() {
                return this.processedData;
            }

            getRawData() {
                return this.rawData;
            }

            getOrganizationList() {
                return Array.from(this.processedData.organizations.keys()).sort();
            }

            getErrors() {
                return this.errors;
            }

            isDataProcessed() {
                return this.isProcessed;
            }
        }

        window.OrgChartTool.DataProcessor = DataProcessor;

    })();

    // 3. Table Editor Module - Simplified version
    (function() {
        'use strict';

        class TableEditor {
            constructor(container) {
                this.container = container;
                this.data = [];
                this.selectedRows = new Set();
                this.currentEditCell = null;
                this.t = window.OrgChartTool.Config.t;
                
                // Column definitions
                this.allColumns = [
                    'level', 'teamName', 'exactTeamName', 'upperTeam', 'teamId',
                    'role', 'role2ndLang', 'teamBoss', 'picName', 'picName2ndLang',
                    'concurrent', 'employeeCd', 'grade', 'memo',
                    'borderColor', 'headerBgColor', 'headerTextColor'
                ];
                
                // Column visibility (default: show essential columns)
                this.columnVisibility = new Map();
                this.defaultVisibleColumns = [
                    'level', 'teamName', 'upperTeam', 'role', 'teamBoss', 'picName', 'concurrent'
                ];
                
                // Initialize column visibility
                this.allColumns.forEach(col => {
                    this.columnVisibility.set(col, this.defaultVisibleColumns.includes(col));
                });
            }

            render(rawData) {
                this.data = this.convertRawDataToTableData(rawData);
                this.container.innerHTML = '';
                
                // Create table actions (only Apply Changes)
                const actions = document.createElement('div');
                actions.className = 'table-actions';
                actions.innerHTML = `
                    <button class="btn btn-primary" onclick="window.OrgChartTool.tableEditor.applyChanges()">
                        ${this.t('applyChanges')}
                    </button>
                `;
                this.container.appendChild(actions);
                
                // Create column selector (always visible)
                const columnSelector = document.createElement('div');
                columnSelector.id = 'column-selector';
                columnSelector.className = 'column-selector';
                columnSelector.style.cssText = `
                    background: #f9fafb;
                    padding: 10px;
                    border: 1px solid #e5e7eb;
                    border-radius: 6px;
                    margin-bottom: 10px;
                `;
                
                columnSelector.innerHTML = `
                    <h5 style="margin: 0 0 8px 0; font-size: 14px;">表示列を選択:</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 6px;">
                        ${this.allColumns.map(col => `
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                                <input type="checkbox" ${this.columnVisibility.get(col) ? 'checked' : ''} 
                                    onchange="window.OrgChartTool.tableEditor.toggleColumn('${col}', this.checked)">
                                <span>${this.t(col)}</span>
                            </label>
                        `).join('')}
                    </div>
                `;
                this.container.appendChild(columnSelector);
                
                // Create table
                const tableWrapper = document.createElement('div');
                tableWrapper.className = 'table-wrapper';
                
                const table = document.createElement('table');
                table.className = 'data-table';
                
                // Calculate minimum width based on visible columns
                const visibleColumns = this.allColumns.filter(col => this.columnVisibility.get(col));
                const fixedColumnsWidth = 380; // 40 + 80 + 60 + 200 (row#, actions, level, teamName)
                const scrollableColumns = visibleColumns.filter(col => col !== 'level' && col !== 'teamName');
                
                // Calculate width for scrollable columns with specific widths
                let scrollableColumnsWidth = 0;
                scrollableColumns.forEach(col => {
                    if (col === 'role') scrollableColumnsWidth += 180;
                    else if (col === 'picName') scrollableColumnsWidth += 160;
                    else if (col === 'upperTeam') scrollableColumnsWidth += 180;
                    else if (col === 'teamBoss') scrollableColumnsWidth += 60;
                    else if (col === 'concurrent') scrollableColumnsWidth += 60;
                    else scrollableColumnsWidth += 150;
                });
                
                const totalMinWidth = fixedColumnsWidth + scrollableColumnsWidth;
                table.style.minWidth = `${totalMinWidth}px`;
                
                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Row number column (first)
                const rowNumberHeader = document.createElement('th');
                rowNumberHeader.style.width = '40px';
                rowNumberHeader.style.textAlign = 'center';
                rowNumberHeader.className = 'fixed-column row-number';
                rowNumberHeader.textContent = '#';
                headerRow.appendChild(rowNumberHeader);
                
                // Actions column (second)
                const actionsHeader = document.createElement('th');
                actionsHeader.style.width = '80px';
                actionsHeader.style.textAlign = 'center';
                actionsHeader.className = 'fixed-column actions';
                actionsHeader.innerHTML = `
                    アクション
                    <br><button class="btn btn-sm" onclick="window.OrgChartTool.tableEditor.addRowAtTop()" 
                        style="font-size: 9px; padding: 1px 3px; margin-top: 2px; min-width: 70px;">先頭に追加</button>
                `;
                headerRow.appendChild(actionsHeader);
                
                // Data columns (only visible ones)
                this.allColumns.forEach(col => {
                    if (this.columnVisibility.get(col)) {
                        const th = document.createElement('th');
                        th.style.textAlign = 'center';
                        th.dataset.column = col;
                        
                        // Add fixed class for level and teamName columns
                        if (col === 'level') {
                            th.className = 'fixed-column level';
                            th.style.width = '60px';
                        } else if (col === 'teamName') {
                            th.className = 'fixed-column team-name';
                            th.style.width = '200px';
                        }
                        
                        // Add asterisk for required fields
                        const requiredFields = ['level', 'teamName', 'upperTeam', 'role', 'picName'];
                        const isRequired = requiredFields.includes(col);
                        th.textContent = (isRequired ? '* ' : '') + this.t(col);
                        
                        headerRow.appendChild(th);
                    }
                });
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create body
                const tbody = document.createElement('tbody');
                this.data.forEach((row, index) => {
                    tbody.appendChild(this.createTableRow(row, index));
                });
                table.appendChild(tbody);
                
                tableWrapper.appendChild(table);
                this.container.appendChild(tableWrapper);
            }

            createTableRow(rowData, index) {
                const tr = document.createElement('tr');
                tr.dataset.index = index;
                
                // Row number column (first)
                const rowNumberCell = document.createElement('td');
                rowNumberCell.className = 'fixed-column row-number';
                rowNumberCell.style.textAlign = 'center';
                rowNumberCell.style.verticalAlign = 'middle';
                rowNumberCell.style.fontWeight = 'bold';
                rowNumberCell.style.background = '#f8f9fa';
                rowNumberCell.textContent = index + 1;
                tr.appendChild(rowNumberCell);
                
                // Actions column (second)
                const actionsCell = document.createElement('td');
                actionsCell.className = 'fixed-column actions';
                actionsCell.style.verticalAlign = 'middle';
                actionsCell.innerHTML = `
                    <div style="display: flex; gap: 2px; align-items: center; justify-content: center;">
                        <div style="display: flex; flex-direction: column; gap: 1px;">
                            <button class="btn btn-sm" onclick="window.OrgChartTool.tableEditor.moveRowUp(${index})" 
                                style="font-size: 10px; padding: 1px 3px; min-width: 18px; width: 18px;" title="上へ移動">↑</button>
                            <button class="btn btn-sm" onclick="window.OrgChartTool.tableEditor.moveRowDown(${index})" 
                                style="font-size: 10px; padding: 1px 3px; min-width: 18px; width: 18px;" title="下へ移動">↓</button>
                        </div>
                        <div style="display: flex; gap: 1px;">
                            <button class="btn btn-sm" onclick="window.OrgChartTool.tableEditor.addRowAfter(${index})" 
                                style="font-size: 10px; padding: 1px 3px; min-width: 18px; width: 18px;" title="下に行追加">+</button>
                            <button class="btn btn-sm" onclick="window.OrgChartTool.tableEditor.deleteRow(${index})" 
                                style="font-size: 10px; padding: 1px 3px; min-width: 18px; width: 18px; color: red;" title="削除">×</button>
                        </div>
                    </div>
                `;
                tr.appendChild(actionsCell);
                
                // Data cells (only visible ones)
                this.allColumns.forEach(col => {
                    if (this.columnVisibility.get(col)) {
                        const td = document.createElement('td');
                        td.dataset.column = col;
                        
                        // Add fixed class for level and teamName columns
                        if (col === 'level') {
                            td.className = 'fixed-column level';
                        } else if (col === 'teamName') {
                            td.className = 'fixed-column team-name';
                        }
                        
                        if (col === 'teamBoss' || col === 'concurrent') {
                            td.innerHTML = `<input type="checkbox" ${rowData[col] === 'Y' ? 'checked' : ''} 
                                onchange="window.OrgChartTool.tableEditor.updateCell(${index}, '${col}', this.checked ? 'Y' : 'N')">`;
                        } else if (col === 'upperTeam') {
                            td.innerHTML = this.createUpperTeamSelect(rowData[col] || '', index);
                        } else if (col.includes('Color')) {
                            td.innerHTML = `
                                <input type="color" class="color-input" value="${rowData[col] || '#000000'}"
                                    onchange="window.OrgChartTool.tableEditor.updateCell(${index}, '${col}', this.value)">
                            `;
                        } else {
                            td.appendChild(this.createEditableSpan(index, col, rowData[col]));
                        }
                        
                        tr.appendChild(td);
                    }
                });
                
                return tr;
            }

            editCell(rowIndex, column) {
                if (this.currentEditCell) {
                    this.saveCurrentEdit();
                }
                
                const cell = document.querySelector(`tr[data-index="${rowIndex}"] td[data-column="${column}"] span`);
                if (!cell) return;
                
                const currentValue = this.data[rowIndex][column] || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'cell-editor';
                input.value = currentValue;
                
                input.onblur = () => this.saveCurrentEdit();
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') this.saveCurrentEdit();
                    if (e.key === 'Escape') this.cancelEdit();
                };
                
                this.currentEditCell = { rowIndex, column, input, cell, originalValue: currentValue };
                cell.innerHTML = '';
                cell.appendChild(input);
                input.focus();
                input.select();
            }

            saveCurrentEdit() {
                if (!this.currentEditCell) return;
                
                const { rowIndex, column, input, cell } = this.currentEditCell;
                const newValue = input.value;
                
                this.updateCell(rowIndex, column, newValue);
                
                // Restore the cell with proper formatting
                const span = document.createElement('span');
                span.style.display = 'block';
                span.style.minHeight = '20px';
                span.style.cursor = 'pointer';
                span.style.padding = '4px';
                span.title = 'クリックで編集';
                
                if (!newValue) {
                    span.style.color = '#999';
                    span.style.fontStyle = 'italic';
                    span.textContent = '(空白)';
                } else {
                    span.textContent = newValue;
                }
                
                // Add click event listener directly
                span.addEventListener('click', () => {
                    this.editCell(rowIndex, column);
                });
                
                cell.innerHTML = '';
                cell.appendChild(span);
                
                this.currentEditCell = null;
            }

            cancelEdit() {
                if (!this.currentEditCell) return;
                
                const { rowIndex, column, cell, originalValue } = this.currentEditCell;
                
                // Restore the cell with proper formatting
                const span = document.createElement('span');
                span.style.display = 'block';
                span.style.minHeight = '20px';
                span.style.cursor = 'pointer';
                span.style.padding = '4px';
                span.title = 'クリックで編集';
                
                if (!originalValue) {
                    span.style.color = '#999';
                    span.style.fontStyle = 'italic';
                    span.textContent = '(空白)';
                } else {
                    span.textContent = originalValue;
                }
                
                // Add click event listener directly
                span.addEventListener('click', () => {
                    this.editCell(rowIndex, column);
                });
                
                cell.innerHTML = '';
                cell.appendChild(span);
                
                this.currentEditCell = null;
            }

            createEditableSpan(rowIndex, column, value) {
                const span = document.createElement('span');
                span.style.display = 'block';
                span.style.minHeight = '20px';
                span.style.cursor = 'pointer';
                span.style.padding = '4px';
                span.title = 'クリックで編集';
                
                const cellValue = value || '';
                if (!cellValue) {
                    span.style.color = '#999';
                    span.style.fontStyle = 'italic';
                    span.textContent = '(空白)';
                } else {
                    span.textContent = cellValue;
                }
                
                // Add click event listener
                span.addEventListener('click', () => {
                    this.editCell(rowIndex, column);
                });
                
                return span;
            }

            updateCell(rowIndex, column, value) {
                if (column === 'level') {
                    value = parseInt(value) || 1;
                }
                this.data[rowIndex][column] = value;
                
                // Refresh upper team dropdowns when team names change
                if (column === 'teamName') {
                    setTimeout(() => this.refreshUpperTeamDropdowns(), 100);
                }
            }

            createUpperTeamSelect(currentValue, rowIndex) {
                // Get all team names for the dropdown
                const teamOptions = [...new Set(this.data.map(row => row.teamName).filter(name => name && name.trim() !== ''))];
                
                // Check if current value is TOP
                const isTopSelected = currentValue && currentValue.trim().toUpperCase() === 'TOP';
                let options = `<option value="TOP" ${isTopSelected ? 'selected' : ''}>TOP</option>`;
                
                teamOptions.forEach(teamName => {
                    const selected = currentValue === teamName ? 'selected' : '';
                    options += `<option value="${teamName}" ${selected}>${teamName}</option>`;
                });
                
                // Add selected value if it's not in the list (for data integrity)
                if (currentValue && !isTopSelected && !teamOptions.includes(currentValue)) {
                    options += `<option value="${currentValue}" selected>${currentValue}</option>`;
                }
                
                return `<select onchange="window.OrgChartTool.tableEditor.updateCell(${rowIndex}, 'upperTeam', this.value)" style="width: 100%;">
                    ${options}
                </select>`;
            }


            createNewRowData() {
                return {
                    level: 1,
                    teamName: 'New Team',
                    exactTeamName: '',
                    upperTeam: 'TOP',
                    teamId: '',
                    role: 'New Role',
                    role2ndLang: '',
                    teamBoss: 'N',
                    picName: 'New Person',
                    picName2ndLang: '',
                    concurrent: 'N',
                    employeeCd: '',
                    grade: '',
                    memo: '',
                    borderColor: '#000000',
                    headerBgColor: '#ffffff',
                    headerTextColor: '#000000'
                };
            }

            addRowAtTop() {
                const newRow = this.createNewRowData();
                this.data.unshift(newRow);
                this.render(this.getTableDataAsRaw());
            }

            addRowAfter(index) {
                const newRow = this.createNewRowData();
                this.data.splice(index + 1, 0, newRow);
                this.render(this.getTableDataAsRaw());
            }

            moveRowUp(index) {
                if (index > 0) {
                    const temp = this.data[index];
                    this.data[index] = this.data[index - 1];
                    this.data[index - 1] = temp;
                    this.render(this.getTableDataAsRaw());
                }
            }

            moveRowDown(index) {
                if (index < this.data.length - 1) {
                    const temp = this.data[index];
                    this.data[index] = this.data[index + 1];
                    this.data[index + 1] = temp;
                    this.render(this.getTableDataAsRaw());
                }
            }

            deleteRow(index) {
                this.data.splice(index, 1);
                this.selectedRows.delete(index);
                this.render(this.getTableDataAsRaw());
            }

            deleteSelected() {
                const indicesToDelete = Array.from(this.selectedRows).sort((a, b) => b - a);
                indicesToDelete.forEach(index => {
                    this.data.splice(index, 1);
                });
                this.selectedRows.clear();
                this.render(this.getTableDataAsRaw());
            }
            
            refreshUpperTeamDropdowns() {
                // Update all upper team dropdowns when team names change
                const upperTeamSelects = this.container.querySelectorAll('td[data-column="upperTeam"] select');
                upperTeamSelects.forEach((select, index) => {
                    const currentValue = select.value;
                    const newHTML = this.createUpperTeamSelect(currentValue, index);
                    select.parentElement.innerHTML = newHTML;
                });
            }
            
            toggleColumn(columnName, isVisible) {
                this.columnVisibility.set(columnName, isVisible);
                // Re-render the table with new column visibility
                this.render(this.getTableDataAsRaw());
            }

            validateData() {
                const warnings = [];
                const errors = [];
                const t = this.t;
                
                // Track employee codes for duplicate detection
                const employeeCodes = new Set();
                const teamBossMap = new Map(); // team -> boss count
                
                this.data.forEach((row, index) => {
                    const rowNum = index + 1;
                    
                    // Required field validation
                    if (!row.level || row.level === '') {
                        errors.push({
                            message: `${t('level')} is required`,
                            rowNumbers: [rowNum]
                        });
                    } else {
                        const level = parseInt(row.level);
                        if (isNaN(level) || level < 1 || level > 10) {
                            errors.push({
                                message: `${t('level')} must be between 1-10`,
                                rowNumbers: [rowNum]
                            });
                        }
                    }
                    
                    if (!row.teamName || row.teamName.trim() === '') {
                        errors.push({
                            message: `${t('teamName')} is required`,
                            rowNumbers: [rowNum]
                        });
                    }
                    
                    if (!row.role || row.role.trim() === '') {
                        errors.push({
                            message: `${t('role')} is required`,
                            rowNumbers: [rowNum]
                        });
                    }
                    
                    if (!row.picName || row.picName.trim() === '') {
                        errors.push({
                            message: `${t('picName')} is required`,
                            rowNumbers: [rowNum]
                        });
                    }
                    
                    // Upper team validation
                    if (row.upperTeam && row.upperTeam.trim() !== '') {
                        const upperTeam = row.upperTeam.trim();
                        
                        // Check if upper team equals own team (self-reference)
                        if (upperTeam === row.teamName) {
                            errors.push({
                                message: `Team cannot reference itself as upper team`,
                                rowNumbers: [rowNum]
                            });
                        }
                        
                        // Check if upper team exists in data (except for "TOP")
                        if (upperTeam.toUpperCase() !== 'TOP') {
                            const upperTeamExists = this.data.some(otherRow => 
                                otherRow.teamName && otherRow.teamName.trim() === upperTeam
                            );
                            if (!upperTeamExists) {
                                errors.push({
                                    message: `Upper team "${upperTeam}" does not exist`,
                                    rowNumbers: [rowNum]
                                });
                            }
                        }
                        
                        // Hierarchy level validation (upper team should have lower level, except for "TOP")
                        if (upperTeam.toUpperCase() !== 'TOP') {
                            const upperTeamRow = this.data.find(otherRow => 
                                otherRow.teamName && otherRow.teamName.trim() === upperTeam
                            );
                            if (upperTeamRow && parseInt(upperTeamRow.level) >= parseInt(row.level)) {
                                warnings.push({
                                    message: `Upper team level should be lower than current team level`,
                                    rowNumbers: [rowNum]
                                });
                            }
                        }
                    }
                    
                    // Team boss validation
                    if (row.teamBoss === 'Y' || row.teamBoss === true) {
                        const teamName = row.teamName;
                        if (!teamBossMap.has(teamName)) {
                            teamBossMap.set(teamName, 0);
                        }
                        teamBossMap.set(teamName, teamBossMap.get(teamName) + 1);
                    }
                    
                    // Employee code duplication check
                    if (row.employeeCd && row.employeeCd.trim() !== '') {
                        const empCode = row.employeeCd.trim();
                        if (employeeCodes.has(empCode)) {
                            // Find all rows with this employee code
                            const duplicateRows = this.data.map((r, i) => 
                                r.employeeCd && r.employeeCd.trim() === empCode ? i + 1 : null
                            ).filter(n => n !== null);
                            
                            errors.push({
                                message: `Employee code "${empCode}" is duplicated`,
                                rowNumbers: duplicateRows
                            });
                        }
                        employeeCodes.add(empCode);
                    }
                });
                
                // Team boss validation (uniqueness and existence)
                const allTeamNames = new Set(this.data.map(row => row.teamName).filter(name => name && name.trim() !== ''));
                
                teamBossMap.forEach((count, teamName) => {
                    if (count > 1) {
                        errors.push({
                            message: `Team "${teamName}" ${t('multipleTeamBossError')}`,
                            rowNumbers: this.data.map((row, index) => 
                                (row.teamName === teamName && (row.teamBoss === 'Y' || row.teamBoss === true)) ? index + 1 : null
                            ).filter(num => num !== null)
                        });
                    }
                });
                
                // Check for teams without team boss
                allTeamNames.forEach(teamName => {
                    if (!teamBossMap.has(teamName)) {
                        const rowNumbers = this.data.map((row, index) => 
                            row.teamName === teamName ? index + 1 : null
                        ).filter(num => num !== null);
                        warnings.push({
                            message: `Team "${teamName}" ${t('noTeamBoss')}`,
                            rowNumbers: rowNumbers
                        });
                    }
                });
                
                // TOP team validation
                const topTeams = this.data.filter(row => 
                    row.upperTeam && row.upperTeam.trim().toUpperCase() === 'TOP'
                );
                
                console.log('TOP teams found:', topTeams.length);
                console.log('TOP teams data:', topTeams.map(row => `${row.teamName} -> ${row.upperTeam}`));
                
                if (topTeams.length === 0) {
                    errors.push({
                        message: t('noTOP'),
                        rowNumbers: []
                    });
                } else if (topTeams.length > 1) {
                    warnings.push({
                        message: `${topTeams.length} ${t('multipleTOP')}`,
                        rowNumbers: topTeams.map(row => 
                            this.data.indexOf(row) + 1
                        )
                    });
                }
                
                // Check for teams with empty upper team (should be "TOP")
                const emptyUpperTeams = this.data.filter((row, index) => 
                    !row.upperTeam || row.upperTeam.trim() === ''
                );
                if (emptyUpperTeams.length > 0) {
                    errors.push({
                        message: 'Teams with empty upper team found. Top-level teams must have "TOP" as upper team.',
                        rowNumbers: emptyUpperTeams.map(row => 
                            this.data.indexOf(row) + 1
                        )
                    });
                }
                
                return { warnings, errors };
            }

            showValidationDialog(errors, warnings) {
                const t = this.t;
                
                // Create modal dialog
                const modal = document.createElement('div');
                modal.className = 'validation-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'validation-dialog';
                dialog.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    padding: 20px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                `;
                
                const title = document.createElement('h3');
                title.textContent = errors.length > 0 ? 
                    (t('validationErrors') || 'Validation Errors') : 
                    (t('validationWarnings') || 'Validation Warnings');
                title.style.cssText = `
                    margin: 0 0 15px 0;
                    color: ${errors.length > 0 ? '#d32f2f' : '#f57c00'};
                `;
                dialog.appendChild(title);
                
                // Error list
                if (errors.length > 0) {
                    const errorSection = document.createElement('div');
                    errorSection.innerHTML = `<h4 style="color: #d32f2f; margin: 10px 0;">エラー (修正が必要):</h4>`;
                    
                    errors.forEach((error, index) => {
                        const errorItem = document.createElement('div');
                        errorItem.style.cssText = `
                            margin: 8px 0;
                            padding: 8px;
                            background: #ffebee;
                            border-left: 4px solid #d32f2f;
                            cursor: pointer;
                            border-radius: 4px;
                        `;
                        
                        const rowInfo = error.rowNumbers.length > 0 ? 
                            `[行 ${error.rowNumbers.join(', ')}] ` : '';
                        errorItem.innerHTML = `
                            <div style="font-weight: bold; color: #d32f2f;">
                                ${rowInfo}${error.message}
                            </div>
                            <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                クリックして該当行に移動
                            </div>
                        `;
                        
                        errorItem.onclick = () => {
                            this.scrollToRow(error.rowNumbers[0]);
                            modal.remove();
                        };
                        
                        errorSection.appendChild(errorItem);
                    });
                    
                    dialog.appendChild(errorSection);
                }
                
                // Warning list
                if (warnings.length > 0) {
                    const warningSection = document.createElement('div');
                    warningSection.innerHTML = `<h4 style="color: #f57c00; margin: 10px 0;">警告:</h4>`;
                    
                    warnings.forEach((warning, index) => {
                        const warningItem = document.createElement('div');
                        warningItem.style.cssText = `
                            margin: 8px 0;
                            padding: 8px;
                            background: #fff8e1;
                            border-left: 4px solid #f57c00;
                            cursor: pointer;
                            border-radius: 4px;
                        `;
                        
                        const rowInfo = warning.rowNumbers.length > 0 ? 
                            `[行 ${warning.rowNumbers.join(', ')}] ` : '';
                        warningItem.innerHTML = `
                            <div style="font-weight: bold; color: #f57c00;">
                                ${rowInfo}${warning.message}
                            </div>
                            <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                クリックして該当行に移動
                            </div>
                        `;
                        
                        warningItem.onclick = () => {
                            this.scrollToRow(warning.rowNumbers[0]);
                            modal.remove();
                        };
                        
                        warningSection.appendChild(warningItem);
                    });
                    
                    dialog.appendChild(warningSection);
                }
                
                // Buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    margin-top: 20px;
                    text-align: right;
                    display: flex;
                    gap: 10px;
                    justify-content: flex-end;
                `;
                
                const closeButton = document.createElement('button');
                closeButton.textContent = errors.length > 0 ? '閉じる' : 'キャンセル';
                closeButton.className = 'btn';
                closeButton.onclick = () => modal.remove();
                buttonContainer.appendChild(closeButton);
                
                // Only show "Ignore warnings" button if there are only warnings
                if (errors.length === 0 && warnings.length > 0) {
                    const ignoreButton = document.createElement('button');
                    ignoreButton.textContent = '警告を無視して実行';
                    ignoreButton.className = 'btn btn-primary';
                    ignoreButton.onclick = () => {
                        modal.remove();
                        this.proceedWithChanges();
                    };
                    buttonContainer.appendChild(ignoreButton);
                }
                
                dialog.appendChild(buttonContainer);
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };
            }
            
            scrollToRow(rowNumber) {
                if (!rowNumber) return;
                
                const tableRow = this.container.querySelector(`tr[data-index="${rowNumber - 1}"]`);
                if (tableRow) {
                    tableRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the row temporarily
                    tableRow.style.backgroundColor = '#ffeb3b';
                    setTimeout(() => {
                        tableRow.style.backgroundColor = '';
                    }, 2000);
                }
            }
            
            proceedWithChanges() {
                // Trigger data update in main app
                if (window.OrgChartTool.App && window.OrgChartTool.App.uiController) {
                    window.OrgChartTool.App.uiController.updateDataFromTable(this.data);
                }
            }

            applyChanges() {
                // Validate data first
                const validation = this.validateData();
                
                // Show validation dialog if there are any issues
                if (validation.errors.length > 0 || validation.warnings.length > 0) {
                    this.showValidationDialog(validation.errors, validation.warnings);
                    return;
                }
                
                // No issues, proceed directly
                this.proceedWithChanges();
            }

            convertRawDataToTableData(rawData) {
                const processor = new window.OrgChartTool.DataProcessor();
                return rawData.map(row => {
                    const tableRow = {};
                    Object.keys(processor.COLUMN_MAPPING).forEach(key => {
                        const index = processor.COLUMN_MAPPING[key];
                        let value = row[index] || '';
                        
                        // Normalize upperTeam: convert "top", "Top", etc. to "TOP"
                        if (key === 'upperTeam' && value && typeof value === 'string' && value.toLowerCase() === 'top') {
                            value = 'TOP';
                        }
                        
                        tableRow[key] = value;
                    });
                    return tableRow;
                });
            }

            getTableDataAsRaw() {
                const processor = new window.OrgChartTool.DataProcessor();
                return this.data.map(row => {
                    const rawRow = new Array(17).fill('');
                    Object.keys(processor.COLUMN_MAPPING).forEach(key => {
                        const index = processor.COLUMN_MAPPING[key];
                        rawRow[index] = row[key] || '';
                    });
                    return rawRow;
                });
            }
            
            isActive() {
                return this.container && this.container.parentNode && this.data && this.data.length > 0;
            }
        }

        window.OrgChartTool.TableEditor = TableEditor;

    })();

    // 4. Layout Calculator Module
    (function() {
        'use strict';

        class LayoutCalculator {
            constructor() {
                this.processedData = null;
                this.cachedLayout = null;
                this.spacingConfig = {
                    x: 72,
                    y: 140,
                    margin: 50
                };
                
                // Walker's Algorithm configuration
                this.walkerConfig = {
                    SIBLING_SPACING: 20,    // Minimum distance between sibling nodes
                    SUBTREE_SPACING: 40,    // Minimum distance between subtrees
                    LEVEL_HEIGHT: 200,      // Vertical distance between levels (reduced from 340)
                    NODE_WIDTH: 138,        // Width of each node
                    NODE_HEIGHT: 160        // Height of each node
                };
            }

            calculateLayout(organizations, baseOrg = null, options = {}) {
                try {
                    console.log('[LAYOUT] Starting calculateLayout with Walker\'s Algorithm');
                    console.log('[LAYOUT] Input organizations:', organizations?.length);
                    console.log('[LAYOUT] First organization sample:', organizations?.[0]);
                    
                    if (!organizations || !Array.isArray(organizations) || organizations.length === 0) {
                        throw new Error('Organizations array is empty or invalid');
                    }
                    
                    // Use Walker's Algorithm for layout
                    return this.calculateLayoutWithWalker(organizations, baseOrg, options);
                    
                } catch (error) {
                    throw new Error(`Failed to calculate layout: ${error.message}`);
                }
            }

            groupByLevel(organizations) {
                const levelGroups = new Map();
                
                organizations.forEach(org => {
                    try {
                        const orgData = (typeof org === 'object' && org !== null) ? org : null;
                        
                        if (orgData && typeof orgData.level === 'number' && orgData.level > 0) {
                            const level = orgData.level;
                            if (!levelGroups.has(level)) {
                                levelGroups.set(level, []);
                            }
                            levelGroups.get(level).push(orgData);
                        }
                    } catch (error) {
                        console.warn('Error processing organization:', error);
                    }
                });
                
                return new Map([...levelGroups.entries()].sort((a, b) => a[0] - b[0]));
            }

            calculateInitialPositions(levelGroups, spacingX, spacingY, boxConfig) {
                const levelPositions = new Map();
                let currentY = 20;
                
                const sortedLevels = Array.from(levelGroups.keys()).sort((a, b) => a - b);
                
                // Process levels from top to bottom to maintain coordinate consistency
                const minLevel = Math.min(...sortedLevels);
                console.log(`[LAYOUT] Minimum level found: ${minLevel}`);
                
                for (const level of sortedLevels) {
                    const orgs = levelGroups.get(level);
                    
                    console.log(`[LAYOUT] Processing level ${level} with ${orgs.length} organizations`);
                    
                    if (level === minLevel) {
                        // Top level (could be level 1 or another starting level): start from a fixed position
                        console.log(`[LAYOUT] Using top level layout for level ${level} (minimum level)`);
                        const levelLayout = this.calculateTopLevelLayout(orgs, level, currentY, spacingX, spacingY, boxConfig);
                        levelPositions.set(level, levelLayout);
                        currentY = levelLayout.maxY + spacingY;
                        console.log(`[LAYOUT] Top level layout complete: ${levelLayout.nodes.length} nodes`);
                    } else {
                        // Child levels: position relative to parents
                        console.log(`[LAYOUT] Using child level layout for level ${level}`);
                        const levelLayout = this.calculateChildLevelLayout(orgs, level, currentY, spacingX, spacingY, boxConfig, levelPositions);
                        levelPositions.set(level, levelLayout);
                        currentY = levelLayout.maxY + spacingY;
                        console.log(`[LAYOUT] Child level layout complete: ${levelLayout.nodes.length} nodes`);
                    }
                }
                
                return levelPositions;
            }
            
            calculateTopLevelLayout(organizations, level, startY, spacingX, spacingY, boxConfig) {
                console.log(`[DEBUG] calculateTopLevelLayout called with ${organizations.length} orgs at level ${level}`);
                const nodes = [];
                const boxWidth = parseInt(boxConfig.width) || 138;
                const boxHeight = parseInt(boxConfig.height) || 160;
                
                // Top level organizations should be centered
                let currentX = 100; // Start with some margin
                
                organizations.forEach((org, index) => {
                    const node = {
                        id: org.id || org.teamName,
                        x: currentX,
                        y: startY,
                        width: boxWidth,
                        height: boxHeight,
                        level: level,
                        data: org,
                        parentGroup: null
                    };
                    nodes.push(node);
                    console.log(`[DEBUG] Top level node: ${org.teamName} at x=${currentX}`);
                    currentX += boxWidth + spacingX;
                });
                
                console.log(`[DEBUG] Top level layout complete: ${nodes.length} nodes created`);
                return {
                    level: level,
                    nodes: nodes,
                    y: startY,
                    maxY: startY + boxHeight,
                    totalWidth: currentX - spacingX
                };
            }
            
            calculateChildLevelLayout(organizations, level, startY, spacingX, spacingY, boxConfig, allLevelPositions) {
                console.log(`[DEBUG] calculateChildLevelLayout called with ${organizations.length} orgs at level ${level}`);
                const nodes = [];
                const boxWidth = parseInt(boxConfig.width) || 138;
                const boxHeight = parseInt(boxConfig.height) || 160;
                
                // Group children by their parent
                const parentGroups = new Map();
                const orphans = [];
                
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        if (!parentGroups.has(org.upperTeam)) {
                            parentGroups.set(org.upperTeam, []);
                        }
                        parentGroups.get(org.upperTeam).push(org);
                    } else {
                        orphans.push(org);
                    }
                });
                
                // Find parent nodes across ALL levels (not just immediate parent level)
                // This fixes the multi-generational cluster recognition issue
                const parentNodes = new Map();
                const sortedParents = [];
                
                // Search through all previously calculated levels to find parents
                console.log(`[DEBUG] Searching for parents in ${allLevelPositions.size} levels for level ${level}`);
                allLevelPositions.forEach((levelLayout, levelKey) => {
                    if (levelKey < level) { // Only look at levels above current level
                        console.log(`[DEBUG] Checking level ${levelKey} with ${levelLayout.nodes.length} nodes`);
                        levelLayout.nodes.forEach(node => {
                            parentNodes.set(node.data.teamName, node);
                            if (parentGroups.has(node.data.teamName)) {
                                console.log(`[DEBUG] Found parent ${node.data.teamName} at level ${levelKey} with ${parentGroups.get(node.data.teamName).length} children`);
                                sortedParents.push({
                                    name: node.data.teamName,
                                    node: node,
                                    children: parentGroups.get(node.data.teamName),
                                    parentLevel: levelKey
                                });
                            }
                        });
                    }
                });
                
                // Sort parent clusters by their X position to avoid crossing lines
                sortedParents.sort((a, b) => a.node.x - b.node.x);
                console.log(`[DEBUG] Found ${sortedParents.length} parent clusters for level ${level}`);
                
                // Calculate cluster widths and positions to avoid overlaps
                const clusters = [];
                let totalClusterWidth = 0;
                
                sortedParents.forEach(parentInfo => {
                    const children = parentInfo.children;
                    children.sort((a, b) => (a.dataOrder || 0) - (b.dataOrder || 0));
                    
                    // Use immediate children width for now - descendant width calculation may be overcomplicating
                    const immediateChildrenWidth = children.length * boxWidth + (children.length - 1) * Math.min(spacingX * 0.7, 40);
                    const clusterWidth = immediateChildrenWidth;
                    
                    const parentCenterX = parentInfo.node.x + (parentInfo.node.width / 2);
                    
                    clusters.push({
                        parentName: parentInfo.name,
                        parentNode: parentInfo.node,
                        parentLevel: parentInfo.parentLevel,
                        children: children,
                        clusterWidth: clusterWidth,
                        immediateChildrenWidth: immediateChildrenWidth,
                        parentCenterX: parentCenterX,
                        idealStartX: parentCenterX - (clusterWidth / 2)
                    });
                    
                    totalClusterWidth += clusterWidth;
                    
                    console.log(`[LAYOUT] Cluster ${parentInfo.name} (level ${parentInfo.parentLevel}): width=${immediateChildrenWidth}`);
                });
                
                // Adjust cluster positions to avoid overlaps while maintaining parent-child alignment
                const clusterSpacing = 50; // Increased spacing between clusters
                
                // Position each cluster centered under its parent
                clusters.forEach((cluster, index) => {
                    // Calculate ideal position centered under parent
                    const idealStartX = cluster.parentCenterX - (cluster.immediateChildrenWidth / 2);
                    
                    // Position children within this cluster
                    let childX = idealStartX;
                    const childSpacing = Math.min(spacingX * 0.7, 40);
                    
                    cluster.children.forEach((child, childIndex) => {
                        const node = {
                            id: child.id || child.teamName,
                            x: childX,
                            y: startY,
                            width: boxWidth,
                            height: boxHeight,
                            level: level,
                            data: child,
                            parentGroup: cluster.parentName
                        };
                        nodes.push(node);
                        childX += boxWidth + childSpacing;
                    });
                    
                    console.log(`[LAYOUT] Cluster ${cluster.parentName}: parent center=${cluster.parentCenterX}, cluster start=${idealStartX}, width=${cluster.immediateChildrenWidth}`);
                });
                
                // After positioning all nodes, check for overlaps and adjust if necessary
                if (nodes.length > 1) {
                    // Sort nodes by x position
                    nodes.sort((a, b) => a.x - b.x);
                    
                    // Check for overlaps and adjust
                    for (let i = 1; i < nodes.length; i++) {
                        const prevNode = nodes[i - 1];
                        const currentNode = nodes[i];
                        const minSpacing = 20;
                        
                        const requiredX = prevNode.x + prevNode.width + minSpacing;
                        if (currentNode.x < requiredX) {
                            const adjustment = requiredX - currentNode.x;
                            
                            // Move current node and all nodes in the same cluster
                            const currentCluster = currentNode.parentGroup;
                            nodes.forEach(node => {
                                if (node.parentGroup === currentCluster) {
                                    node.x += adjustment;
                                }
                            });
                        }
                    }
                }
                
                // Handle orphans (children without identified parents)
                // Position orphans after the last cluster
                let orphanX = nodes.length > 0 ? Math.max(...nodes.map(n => n.x + n.width)) + 50 : 20;
                orphans.forEach(org => {
                    const node = {
                        id: org.id || org.teamName,
                        x: orphanX,
                        y: startY,
                        width: boxWidth,
                        height: boxHeight,
                        level: level,
                        data: org,
                        parentGroup: null
                    };
                    nodes.push(node);
                    orphanX += boxWidth + spacingX;
                });
                
                return {
                    level: level,
                    nodes: nodes,
                    y: startY,
                    maxY: startY + boxHeight,
                    totalWidth: Math.max(...nodes.map(n => n.x + n.width), orphanX)
                };
            }
            
            calculateLevelLayoutGrouped(organizations, level, startY, spacingX, spacingY, boxConfig) {
                const nodes = [];
                const boxWidth = parseInt(boxConfig.width) || 138;
                const boxHeight = parseInt(boxConfig.height) || 160;
                
                const parentGroups = new Map();
                const orphans = [];
                
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        if (!parentGroups.has(org.upperTeam)) {
                            parentGroups.set(org.upperTeam, []);
                        }
                        parentGroups.get(org.upperTeam).push(org);
                    } else {
                        orphans.push(org);
                    }
                });
                
                parentGroups.forEach((children, parent) => {
                    children.sort((a, b) => (a.dataOrder || 0) - (b.dataOrder || 0));
                });
                
                const sortedParentGroups = Array.from(parentGroups.entries()).sort(([parentA, childrenA], [parentB, childrenB]) => {
                    const minOrderA = Math.min(...childrenA.map(child => child.dataOrder || 0));
                    const minOrderB = Math.min(...childrenB.map(child => child.dataOrder || 0));
                    return minOrderA - minOrderB;
                });
                
                orphans.sort((a, b) => (a.dataOrder || 0) - (b.dataOrder || 0));
                
                let currentX = 20;
                const groupSpacing = Math.max(spacingX * 0.4, 32);
                
                orphans.forEach(org => {
                    const node = {
                        id: org.id || org.teamName,
                        x: currentX,
                        y: startY,
                        width: boxWidth,
                        height: boxHeight,
                        level: level,
                        data: org,
                        parentGroup: null
                    };
                    nodes.push(node);
                    currentX += boxWidth + Math.max(boxWidth / 4, 30);
                });
                
                if (orphans.length > 0) {
                    currentX += groupSpacing;
                }
                
                sortedParentGroups.forEach(([parent, children], groupIndex) => {
                    children.forEach((child, childIndex) => {
                        const node = {
                            id: child.id || child.teamName,
                            x: currentX,
                            y: startY,
                            width: boxWidth,
                            height: boxHeight,
                            level: level,
                            data: child,
                            parentGroup: parent,
                            groupIndex: groupIndex,
                            childIndex: childIndex
                        };
                        nodes.push(node);
                        currentX += boxWidth + Math.max(boxWidth / 4, 30);
                    });
                    
                    currentX += groupSpacing;
                });
                
                return {
                    nodes: nodes,
                    maxY: startY + boxHeight,
                    level: level
                };
            }
            
            resolveOverlapsWithinLevel(nodes) {
                if (nodes.length <= 1) return;
                
                // Sort nodes by x position
                nodes.sort((a, b) => a.x - b.x);
                
                const minSpacing = 20;
                
                for (let i = 1; i < nodes.length; i++) {
                    const currentNode = nodes[i];
                    const prevNode = nodes[i - 1];
                    
                    const requiredX = prevNode.x + prevNode.width + minSpacing;
                    if (currentNode.x < requiredX) {
                        const adjustment = requiredX - currentNode.x;
                        
                        // Move all subsequent nodes to avoid overlap
                        for (let j = i; j < nodes.length; j++) {
                            nodes[j].x += adjustment;
                        }
                    }
                }
            }
            
            fineAdjustParentPositions(levelPositions, organizations) {
                // Build parent-children relationship map
                const childrenMap = new Map();
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        if (!childrenMap.has(org.upperTeam)) {
                            childrenMap.set(org.upperTeam, []);
                        }
                        childrenMap.get(org.upperTeam).push(org.teamName);
                    }
                });
                
                // Only adjust the minimum level (root level) to center it over all children
                const minLevel = Math.min(...Array.from(levelPositions.keys()));
                const rootLevelLayout = levelPositions.get(minLevel);
                
                if (rootLevelLayout && rootLevelLayout.nodes.length === 1) {
                    // Find all descendants of the root node
                    const rootNode = rootLevelLayout.nodes[0];
                    let minX = Infinity;
                    let maxX = -Infinity;
                    
                    // Calculate the bounding box of all nodes except the root
                    levelPositions.forEach((levelLayout, level) => {
                        if (level > minLevel) {
                            levelLayout.nodes.forEach(node => {
                                minX = Math.min(minX, node.x);
                                maxX = Math.max(maxX, node.x + node.width);
                            });
                        }
                    });
                    
                    if (minX !== Infinity && maxX !== -Infinity) {
                        // Center the root node over all descendants
                        const descendantsCenterX = (minX + maxX) / 2;
                        const newRootX = descendantsCenterX - (rootNode.width / 2);
                        
                        console.log(`[LAYOUT] Centering root ${rootNode.data.teamName}: ${rootNode.x} -> ${newRootX}`);
                        rootNode.x = newRootX;
                    }
                }
                
                // Resolve any overlaps within each level (but don't move nodes to match children)
                levelPositions.forEach((levelLayout, level) => {
                    this.resolveOverlapsWithinLevel(levelLayout.nodes);
                });
            }
            
            // Legacy method - keep for compatibility
            adjustParentPositions(levelPositions, organizations) {
                // Build parent-children relationship map
                const childrenMap = new Map();
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        if (!childrenMap.has(org.upperTeam)) {
                            childrenMap.set(org.upperTeam, []);
                        }
                        childrenMap.get(org.upperTeam).push(org.teamName);
                    }
                });
                
                // Process levels from bottom to top to ensure children are positioned first
                const sortedLevels = Array.from(levelPositions.keys()).sort((a, b) => b - a);
                
                for (const level of sortedLevels) {
                    const levelLayout = levelPositions.get(level);
                    
                    levelLayout.nodes.forEach(node => {
                        const children = childrenMap.get(node.data.teamName);
                        if (children && children.length > 0) {
                            const childNodes = this.findChildNodes(children, levelPositions);
                            
                            // Only adjust parent position if children exist and are positioned
                            if (childNodes.length > 0) {
                                // Sort children by x position to get accurate leftmost and rightmost
                                childNodes.sort((a, b) => a.x - b.x);
                                
                                const leftmostChild = childNodes[0];
                                const rightmostChild = childNodes[childNodes.length - 1];
                                
                                // Calculate the span of all children
                                const leftEdge = leftmostChild.x;
                                const rightEdge = rightmostChild.x + rightmostChild.width;
                                const childrenWidth = rightEdge - leftEdge;
                                const childrenCenterX = leftEdge + (childrenWidth / 2);
                                
                                // Position parent at the center of children's span
                                const newX = childrenCenterX - (node.width / 2);
                                
                                console.log(`[LAYOUT] Adjusting parent ${node.data.teamName}: children span ${leftEdge}-${rightEdge}, center at ${childrenCenterX}, parent from ${node.x} to ${newX}`);
                                node.x = newX;
                            }
                        }
                    });
                    
                    // After positioning, resolve any overlaps within the same level
                    this.resolveOverlaps(levelLayout.nodes);
                }
            }
            
            resolveOverlaps(nodes) {
                if (nodes.length <= 1) return;
                
                // Sort nodes by x position
                nodes.sort((a, b) => a.x - b.x);
                
                const minSpacing = 20; // Increased spacing for better clarity
                
                for (let i = 1; i < nodes.length; i++) {
                    const currentNode = nodes[i];
                    const prevNode = nodes[i - 1];
                    
                    const requiredX = prevNode.x + prevNode.width + minSpacing;
                    if (currentNode.x < requiredX) {
                        const adjustment = requiredX - currentNode.x;
                        
                        // Move all subsequent nodes to avoid overlap
                        for (let j = i; j < nodes.length; j++) {
                            nodes[j].x += adjustment;
                        }
                    }
                }
            }
            
            finalizeLayout(levelPositions) {
                // Final pass to ensure consistent layout
                const sortedLevels = Array.from(levelPositions.keys()).sort((a, b) => a - b);
                
                for (const level of sortedLevels) {
                    const levelLayout = levelPositions.get(level);
                    
                    // Ensure minimum spacing and no overlaps
                    this.resolveOverlaps(levelLayout.nodes);
                    
                    // Optional: Adjust Y positions if needed
                    levelLayout.nodes.forEach(node => {
                        // Ensure Y position is consistent for level
                        if (levelLayout.y !== undefined) {
                            node.y = levelLayout.y;
                        }
                    });
                }
                
                console.log('[LAYOUT] Layout finalized with proper spacing and positioning');
            }
            
            findChildNodes(childNames, levelPositions) {
                const childNodes = [];
                levelPositions.forEach(levelLayout => {
                    levelLayout.nodes.forEach(node => {
                        if (childNames.includes(node.data.teamName)) {
                            childNodes.push(node);
                        }
                    });
                });
                return childNodes;
            }
            
            findNodeByTeamName(teamName, levelPositions) {
                for (const levelLayout of levelPositions.values()) {
                    for (const node of levelLayout.nodes) {
                        if (node.data && node.data.teamName === teamName) {
                            return node;
                        }
                    }
                }
                return null;
            }
            
            calculateDescendantWidth(parentName, allLevelPositions, currentLevel, boxWidth, spacingX) {
                // Build a complete tree structure to calculate total descendant width
                const buildDescendantTree = (teamName) => {
                    const children = [];
                    
                    // Find all direct children
                    allLevelPositions.forEach((levelLayout) => {
                        levelLayout.nodes.forEach(node => {
                            if (node.data.upperTeam === teamName) {
                                children.push({
                                    teamName: node.data.teamName,
                                    level: node.level,
                                    width: boxWidth,
                                    subtree: buildDescendantTree(node.data.teamName)
                                });
                            }
                        });
                    });
                    
                    return children;
                };
                
                // Calculate width for a tree structure
                const calculateTreeWidth = (children) => {
                    if (children.length === 0) return 0;
                    
                    // Group children by level
                    const levelGroups = new Map();
                    children.forEach(child => {
                        if (!levelGroups.has(child.level)) {
                            levelGroups.set(child.level, []);
                        }
                        levelGroups.get(child.level).push(child);
                    });
                    
                    let maxWidth = 0;
                    
                    // Calculate width for each level
                    levelGroups.forEach((levelChildren) => {
                        const directWidth = levelChildren.length * boxWidth + 
                                          (levelChildren.length - 1) * Math.min(spacingX * 0.7, 40);
                        
                        // Calculate total width including subtrees
                        let subtreeWidth = 0;
                        levelChildren.forEach(child => {
                            subtreeWidth += calculateTreeWidth(child.subtree);
                        });
                        
                        // Use the maximum of direct width or subtree width
                        maxWidth = Math.max(maxWidth, Math.max(directWidth, subtreeWidth));
                    });
                    
                    return maxWidth;
                };
                
                // Build the descendant tree and calculate total width
                const descendantTree = buildDescendantTree(parentName);
                const totalWidth = calculateTreeWidth(descendantTree);
                
                console.log(`[LAYOUT] Multi-level descendant width for ${parentName}: ${totalWidth} (${descendantTree.length} direct children)`);
                return totalWidth || boxWidth; // Return at least box width if no descendants
            }
            
            findParentLevel(parentName, allLevelPositions, currentLevel) {
                // Find which level contains the parent node
                for (const [levelKey, levelLayout] of allLevelPositions.entries()) {
                    if (levelKey < currentLevel) {
                        const found = levelLayout.nodes.find(node => node.data.teamName === parentName);
                        if (found) {
                            return levelKey;
                        }
                    }
                }
                return currentLevel - 1; // Default to immediate parent level
            }

            calculateConnections(levelPositions, organizations) {
                const connections = [];
                
                // Build parent-children map to validate relationships
                const childrenMap = new Map();
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        if (!childrenMap.has(org.upperTeam)) {
                            childrenMap.set(org.upperTeam, []);
                        }
                        childrenMap.get(org.upperTeam).push(org.teamName);
                    }
                });
                
                // Create connections only for verified parent-child relationships
                organizations.forEach(org => {
                    const orgData = (typeof org === 'object') ? org : null;
                    if (orgData && orgData.upperTeam) {
                        // Find the actual parent organization
                        const parentOrg = organizations.find(parent => {
                            const parentData = (typeof parent === 'object') ? parent : null;
                            return parentData && parentData.teamName === orgData.upperTeam;
                        });
                        
                        if (parentOrg) {
                            // Verify both nodes exist in the layout
                            const parentNode = this.findNodeByTeamName(parentOrg.teamName, levelPositions);
                            const childNode = this.findNodeByTeamName(orgData.teamName, levelPositions);
                            
                            if (parentNode && childNode) {
                                // Additional validation: ensure this is a direct parent-child relationship
                                // and not crossing other clusters
                                const isValidConnection = this.validateConnectionPath(parentNode, childNode, levelPositions);
                                
                                if (isValidConnection) {
                                    const connection = this.createConnectionFromObjects(parentOrg, orgData, levelPositions);
                                    if (connection) {
                                        console.log(`[LAYOUT] Creating validated connection from ${parentOrg.teamName} to ${orgData.teamName}`);
                                        connections.push(connection);
                                    }
                                } else {
                                    console.log(`[LAYOUT] Skipping connection - invalid path: ${parentOrg.teamName} -> ${orgData.teamName}`);
                                }
                            } else {
                                console.log(`[LAYOUT] Skipping connection - missing node: parent=${!!parentNode}, child=${!!childNode}`);
                            }
                        } else {
                            console.log(`[LAYOUT] Skipping connection - parent not found for ${orgData.teamName} -> ${orgData.upperTeam}`);
                        }
                    }
                });
                
                console.log(`[LAYOUT] Total validated connections created: ${connections.length}`);
                return this.optimizeConnectionPaths(connections);
            }
            
            validateConnectionPath(parentNode, childNode, levelPositions) {
                // Basic validation: check if the connection makes sense geometrically
                
                // 1. Parent should be above child (different levels)
                if (parentNode.level >= childNode.level) {
                    return false;
                }
                
                // 2. For now, allow all direct parent-child connections
                // TODO: Add more sophisticated crossing detection if needed
                
                return true;
            }

            createConnectionFromObjects(parentOrg, childOrg, levelPositions) {
                try {
                    const parentId = parentOrg.id || parentOrg.teamName;
                    const childId = childOrg.id || childOrg.teamName;
                    
                    let parentNode = null;
                    let childNode = null;
                    
                    for (const levelNodes of levelPositions.values()) {
                        const parentFound = levelNodes.nodes.find(node => 
                            node.id === parentId || node.data?.teamName === parentOrg.teamName
                        );
                        const childFound = levelNodes.nodes.find(node => 
                            node.id === childId || node.data?.teamName === childOrg.teamName
                        );
                        
                        if (parentFound) parentNode = parentFound;
                        if (childFound) childNode = childFound;
                    }
                    
                    if (parentNode && childNode) {
                        return {
                            from: parentId,
                            to: childId,
                            fromPos: {
                                x: parentNode.x,
                                y: parentNode.y,
                                width: parentNode.width,
                                height: parentNode.height
                            },
                            toPos: {
                                x: childNode.x,
                                y: childNode.y,
                                width: childNode.width,
                                height: childNode.height
                            },
                            fromX: parentNode.x + (parentNode.width / 2),
                            fromY: parentNode.y + parentNode.height,
                            toX: childNode.x + (childNode.width / 2),
                            toY: childNode.y,
                            type: 'hierarchy'
                        };
                    }
                    
                    return null;
                } catch (error) {
                    return null;
                }
            }

            calculateBounds(nodes) {
                if (nodes.length === 0) {
                    return { width: 0, height: 0, minX: 0, minY: 0, maxX: 0, maxY: 0 };
                }
                
                let minX = Infinity;
                let minY = Infinity;
                let maxX = -Infinity;
                let maxY = -Infinity;
                
                nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + node.width);
                    maxY = Math.max(maxY, node.y + node.height);
                });
                
                const margin = this.spacingConfig.margin;
                
                return {
                    minX: minX - margin,
                    minY: minY - margin,
                    maxX: maxX + margin,
                    maxY: maxY + margin,
                    width: maxX - minX + (margin * 2),
                    height: maxY - minY + (margin * 2)
                };
            }
            
            // Walker's Algorithm Implementation
            calculateLayoutWithWalker(organizations, baseOrg = null, options = {}) {
                console.log('[WALKER] Starting Walker\'s Algorithm layout with options:', options);
                
                if (!organizations || organizations.length === 0) {
                    return { nodes: [], connections: [], bounds: {} };
                }
                
                // Extract options
                const {
                    hideManagers = false,
                    fontSize = 'medium',
                    boxSize = 'medium',
                    teamNamesOnly = false
                } = options;
                
                // Update walker configuration based on box size and teamNamesOnly option
                this.updateWalkerConfigForBoxSize(boxSize, teamNamesOnly);
                
                // Build tree structure
                const { root, nodeMap } = this.buildTreeStructure(organizations);
                if (!root) {
                    console.error('[WALKER] Failed to build tree structure');
                    return { nodes: [], connections: [], bounds: {} };
                }
                
                // Apply Walker's Algorithm
                this.initializeWalkerProperties(root);
                this.firstWalk(root);
                this.secondWalk(root, 0);
                
                // Convert to layout format
                const layout = this.convertWalkerToLayout(root, nodeMap, organizations, options);
                
                // Add configuration to layout
                layout.config = {
                    boxSize,
                    fontSize,
                    hideManagers,
                    teamNamesOnly,
                    fontConfig: this.getFontConfig(fontSize),
                    boxConfig: this.getBoxConfigForSize(boxSize)
                };
                
                console.log('[WALKER] Layout completed with', layout.nodes.length, 'nodes');
                return layout;
            }
            
            buildTreeStructure(organizations) {
                const nodeMap = new Map();
                let root = null;
                
                // Create nodes
                organizations.forEach(org => {
                    const node = {
                        id: org.teamName,
                        data: org,
                        children: [],
                        parent: null,
                        // Walker's properties
                        prelim: 0,
                        mod: 0,
                        shift: 0,
                        change: 0,
                        ancestor: null,
                        number: 0,
                        level: 0,
                        x: 0,
                        y: 0
                    };
                    node.ancestor = node;
                    nodeMap.set(org.teamName, node);
                });
                
                // Build parent-child relationships
                organizations.forEach(org => {
                    const node = nodeMap.get(org.teamName);
                    if (org.upperTeam && nodeMap.has(org.upperTeam)) {
                        const parent = nodeMap.get(org.upperTeam);
                        parent.children.push(node);
                        node.parent = parent;
                    } else if (!org.upperTeam || org.upperTeam === '') {
                        root = node;
                    }
                });
                
                // Sort children and assign numbers
                nodeMap.forEach(node => {
                    node.children.sort((a, b) => (a.data.dataOrder || 0) - (b.data.dataOrder || 0));
                    node.children.forEach((child, i) => {
                        child.number = i;
                    });
                });
                
                // Assign levels
                if (root) {
                    this.assignLevels(root, 0);
                }
                
                return { root, nodeMap };
            }
            
            assignLevels(node, level) {
                node.level = level;
                node.children.forEach(child => {
                    this.assignLevels(child, level + 1);
                });
            }
            
            initializeWalkerProperties(node) {
                node.prelim = 0;
                node.mod = 0;
                node.shift = 0;
                node.change = 0;
                node.ancestor = node;
                
                node.children.forEach(child => {
                    this.initializeWalkerProperties(child);
                });
            }
            
            firstWalk(node) {
                if (node.children.length === 0) {
                    // Leaf node
                    const leftSibling = this.getLeftSibling(node);
                    if (leftSibling) {
                        node.prelim = leftSibling.prelim + this.walkerConfig.NODE_WIDTH + this.walkerConfig.SIBLING_SPACING;
                    } else {
                        node.prelim = 0;
                    }
                } else {
                    // Internal node
                    let defaultAncestor = node.children[0];
                    
                    // Process all children
                    node.children.forEach(child => {
                        this.firstWalk(child);
                        defaultAncestor = this.apportion(child, defaultAncestor);
                    });
                    
                    this.executeShifts(node);
                    
                    // Center parent over children
                    const leftmostChild = node.children[0];
                    const rightmostChild = node.children[node.children.length - 1];
                    const midpoint = (leftmostChild.prelim + rightmostChild.prelim) / 2;
                    
                    const leftSibling = this.getLeftSibling(node);
                    if (leftSibling) {
                        node.prelim = leftSibling.prelim + this.walkerConfig.NODE_WIDTH + this.walkerConfig.SIBLING_SPACING;
                        node.mod = node.prelim - midpoint;
                    } else {
                        node.prelim = midpoint;
                    }
                }
            }
            
            apportion(node, defaultAncestor) {
                const leftSibling = this.getLeftSibling(node);
                if (!leftSibling) return defaultAncestor;
                
                // Initialize for contour traversal
                let nodeInner = node;
                let nodeOuter = node;
                let leftInner = leftSibling;
                let leftOuter = this.getLeftmostSibling(node);
                
                let sumInner = node.mod;
                let sumOuter = node.mod;
                let sumLeftInner = leftSibling.mod;
                let sumLeftOuter = leftOuter.mod;
                
                // Traverse contours
                while (this.nextRight(leftInner) && this.nextLeft(nodeInner)) {
                    leftInner = this.nextRight(leftInner);
                    nodeInner = this.nextLeft(nodeInner);
                    leftOuter = this.nextLeft(leftOuter);
                    nodeOuter = this.nextRight(nodeOuter);
                    
                    nodeOuter.ancestor = node;
                    
                    // Check for conflicts
                    const shift = (leftInner.prelim + sumLeftInner) - 
                                 (nodeInner.prelim + sumInner) + 
                                 this.walkerConfig.NODE_WIDTH + 
                                 this.walkerConfig.SUBTREE_SPACING;
                    
                    if (shift > 0) {
                        const ancestor = this.ancestor(leftInner, node, defaultAncestor);
                        this.moveSubtree(ancestor, node, shift);
                        sumInner += shift;
                        sumOuter += shift;
                    }
                    
                    sumInner += nodeInner.mod;
                    sumOuter += nodeOuter.mod;
                    sumLeftInner += leftInner.mod;
                    sumLeftOuter += leftOuter.mod;
                }
                
                // Process remaining nodes on either side
                if (this.nextRight(leftInner) && !this.nextRight(nodeOuter)) {
                    nodeOuter.thread = this.nextRight(leftInner);
                    nodeOuter.mod += sumLeftInner - sumOuter;
                }
                
                if (this.nextLeft(nodeInner) && !this.nextLeft(leftOuter)) {
                    leftOuter.thread = this.nextLeft(nodeInner);
                    leftOuter.mod += sumInner - sumLeftOuter;
                    defaultAncestor = node;
                }
                
                return defaultAncestor;
            }
            
            moveSubtree(leftNode, rightNode, shift) {
                const subtrees = rightNode.number - leftNode.number;
                rightNode.change -= shift / subtrees;
                rightNode.shift += shift;
                leftNode.change += shift / subtrees;
                rightNode.prelim += shift;
                rightNode.mod += shift;
            }
            
            executeShifts(node) {
                let shift = 0;
                let change = 0;
                
                // Process children from right to left
                for (let i = node.children.length - 1; i >= 0; i--) {
                    const child = node.children[i];
                    child.prelim += shift;
                    child.mod += shift;
                    change += child.change;
                    shift += child.shift + change;
                }
            }
            
            ancestor(leftNode, node, defaultAncestor) {
                if (leftNode.ancestor.parent === node.parent) {
                    return leftNode.ancestor;
                }
                return defaultAncestor;
            }
            
            getLeftSibling(node) {
                if (!node.parent || node.number === 0) return null;
                return node.parent.children[node.number - 1];
            }
            
            getLeftmostSibling(node) {
                if (!node.parent || node.number === 0) return node;
                return node.parent.children[0];
            }
            
            nextLeft(node) {
                if (node.children.length > 0) {
                    return node.children[0];
                }
                return node.thread || null;
            }
            
            nextRight(node) {
                if (node.children.length > 0) {
                    return node.children[node.children.length - 1];
                }
                return node.thread || null;
            }
            
            secondWalk(node, modifierSum) {
                node.x = node.prelim + modifierSum;
                node.y = node.level * this.walkerConfig.LEVEL_HEIGHT;
                
                node.children.forEach(child => {
                    this.secondWalk(child, modifierSum + node.mod);
                });
            }
            
            convertWalkerToLayout(root, nodeMap, organizations, options = {}) {
                const nodes = [];
                const connections = [];
                
                // Collect all nodes and normalize coordinates
                this.collectNodesFromTree(root, nodes);
                
                // Find bounds
                let minX = Math.min(...nodes.map(n => n.x));
                
                // Shift to positive coordinates and add margins
                // Add extra top offset to avoid overlap with chart controls (only in normal view)
                const isFullscreen = document.querySelector('.chart-container.fullscreen') !== null;
                const topOffset = isFullscreen ? 0 : 30; // Additional space for chart controls in normal view only
                nodes.forEach(node => {
                    node.x = node.x - minX + this.spacingConfig.margin;
                    node.y = node.y + this.spacingConfig.margin + topOffset;
                });
                
                // Get box configuration
                const boxConfig = this.getBoxConfigForSize(options.boxSize || 'medium');
                console.log('[WALKER] Using box config:', boxConfig);
                
                // Convert to layout nodes
                const layoutNodes = nodes.map(node => ({
                    id: node.id,
                    x: node.x,
                    y: node.y,
                    width: boxConfig.width || 138,
                    height: boxConfig.height || 160,
                    level: node.level,
                    data: node.data
                }));
                
                // Create connections
                organizations.forEach(org => {
                    if (org.upperTeam) {
                        const connection = this.createConnection(org.upperTeam, org.teamName, layoutNodes);
                        if (connection) {
                            connections.push(connection);
                        }
                    }
                });
                
                const bounds = this.calculateBounds(layoutNodes);
                
                return {
                    nodes: layoutNodes,
                    connections: connections,
                    bounds: bounds
                };
            }
            
            collectNodesFromTree(node, nodes) {
                nodes.push(node);
                node.children.forEach(child => {
                    this.collectNodesFromTree(child, nodes);
                });
            }
            
            getBoxConfig() {
                // Get current box size from UI or use default
                try {
                    const boxSizeSelect = document.getElementById('box-size-select');
                    const boxSize = boxSizeSelect ? boxSizeSelect.value : 'medium';
                    const config = window.OrgChartTool.Config?.CONFIG;
                    
                    if (config && config.DEFAULTS && config.DEFAULTS.BOX_SIZES) {
                        const boxConfig = config.DEFAULTS.BOX_SIZES[boxSize] || config.DEFAULTS.BOX_SIZES.medium;
                        return {
                            width: parseInt(boxConfig.width) || 138,
                            height: parseInt(boxConfig.height) || 160
                        };
                    }
                } catch (error) {
                    console.warn('[LAYOUT] Error getting box config:', error);
                }
                
                // Fallback to default values
                return { width: 138, height: 160 };
            }
            
            updateWalkerConfigForBoxSize(boxSize, teamNamesOnly = false) {
                const boxConfig = this.getBoxConfigForSize(boxSize);
                this.walkerConfig.NODE_WIDTH = boxConfig.width;
                
                // Adjust node height based on teamNamesOnly mode
                if (teamNamesOnly) {
                    this.walkerConfig.NODE_HEIGHT = 40; // Header height for team names only
                } else {
                    this.walkerConfig.NODE_HEIGHT = boxConfig.height;
                }
                
                // Adjust level height based on box size and teamNamesOnly mode to ensure vertical lines are visible
                const baseHeight = teamNamesOnly ? 40 : boxConfig.height; // Use header height (40px) for team names only
                switch(boxSize) {
                    case 'small':
                        this.walkerConfig.LEVEL_HEIGHT = baseHeight + (teamNamesOnly ? 30 : 80);
                        break;
                    case 'medium':
                        this.walkerConfig.LEVEL_HEIGHT = baseHeight + (teamNamesOnly ? 40 : 100);
                        break;
                    case 'large':
                        this.walkerConfig.LEVEL_HEIGHT = baseHeight + (teamNamesOnly ? 50 : 140);
                        break;
                    default:
                        this.walkerConfig.LEVEL_HEIGHT = baseHeight + (teamNamesOnly ? 40 : 100);
                }
                
                console.log('[WALKER] Updated config for box size', boxSize, 'teamNamesOnly:', teamNamesOnly, ':', this.walkerConfig);
            }
            
            getBoxConfigForSize(boxSize) {
                try {
                    const config = window.OrgChartTool.Config?.CONFIG;
                    if (config && config.DEFAULTS && config.DEFAULTS.BOX_SIZES) {
                        const boxConfig = config.DEFAULTS.BOX_SIZES[boxSize] || config.DEFAULTS.BOX_SIZES.medium;
                        return {
                            width: parseInt(boxConfig.width) || 138,
                            height: parseInt(boxConfig.height) || 160
                        };
                    }
                } catch (error) {
                    console.warn('[LAYOUT] Error getting box config for size:', error);
                }
                return { width: 138, height: 160 };
            }
            
            getFontConfig(fontSize) {
                try {
                    const config = window.OrgChartTool.Config?.CONFIG;
                    if (config && config.DEFAULTS && config.DEFAULTS.FONT_SIZES) {
                        return config.DEFAULTS.FONT_SIZES[fontSize] || config.DEFAULTS.FONT_SIZES.medium;
                    }
                } catch (error) {
                    console.warn('[LAYOUT] Error getting font config:', error);
                }
                return { size: '14px' };
            }
            
            createConnection(parentId, childId, nodes) {
                const parentNode = nodes.find(n => n.id === parentId || n.data?.teamName === parentId);
                const childNode = nodes.find(n => n.id === childId || n.data?.teamName === childId);
                
                if (parentNode && childNode) {
                    return {
                        from: parentId,
                        to: childId,
                        fromPos: {
                            x: parentNode.x,
                            y: parentNode.y,
                            width: parentNode.width,
                            height: parentNode.height
                        },
                        toPos: {
                            x: childNode.x,
                            y: childNode.y,
                            width: childNode.width,
                            height: childNode.height
                        },
                        fromX: parentNode.x + (parentNode.width / 2),
                        fromY: parentNode.y + parentNode.height,
                        toX: childNode.x + (childNode.width / 2),
                        toY: childNode.y,
                        type: 'hierarchy'
                    };
                }
                return null;
            }

            optimizeConnectionPaths(connections) {
                const validConnections = connections.filter(conn => 
                    conn.fromPos && conn.toPos && conn.from && conn.to
                );
                
                const connectionGroups = new Map();
                
                validConnections.forEach(conn => {
                    const parentId = conn.from;
                    if (!connectionGroups.has(parentId)) {
                        connectionGroups.set(parentId, []);
                    }
                    connectionGroups.get(parentId).push(conn);
                });
                
                const optimizedConnections = [];
                
                connectionGroups.forEach((childConnections, parentId) => {
                    const sortedConnections = childConnections.sort((a, b) => 
                        a.toPos.x - b.toPos.x
                    );
                    
                    if (sortedConnections.length === 1) {
                        const conn = sortedConnections[0];
                        const parentCenterX = conn.fromPos.x + (conn.fromPos.width || 120) / 2;
                        const childCenterX = conn.toPos.x + (conn.toPos.width || 120) / 2;
                        
                        if (Math.abs(parentCenterX - childCenterX) < 10) {
                            optimizedConnections.push({
                                ...conn,
                                connectionType: 'direct-vertical',
                                pathType: 'pure-vertical'
                            });
                        } else {
                            optimizedConnections.push({
                                ...conn,
                                connectionType: 'direct-vertical',
                                pathType: 'l-shaped'
                            });
                        }
                        
                    } else if (sortedConnections.length > 1) {
                        const firstConn = sortedConnections[0];
                        const lastConn = sortedConnections[sortedConnections.length - 1];
                        
                        // Check if we're in team names only mode for height calculation
                        // Note: We don't have access to layout config here, so we need to infer from node heights
                        const teamNamesOnly = (firstConn.fromPos.height || 80) <= 40;
                        const parentHeight = teamNamesOnly ? 40 : (firstConn.fromPos.height || 80);
                        const parentBottomY = firstConn.fromPos.y + parentHeight;
                        const childTopY = firstConn.toPos.y;
                        const bridgeY = parentBottomY + (childTopY - parentBottomY) * 0.6;
                        
                        const parentCenterX = firstConn.fromPos.x + (firstConn.fromPos.width || 120) / 2;
                        
                        optimizedConnections.push({
                            ...firstConn,
                            connectionType: 'parent-to-children',
                            bridgeY: bridgeY,
                            fromX: parentCenterX,
                            fromY: parentBottomY,
                            toX: parentCenterX,
                            toY: bridgeY
                        });
                        
                        const leftX = firstConn.toPos.x + (firstConn.toPos.width || 120) / 2;
                        const rightX = lastConn.toPos.x + (lastConn.toPos.width || 120) / 2;
                        
                        optimizedConnections.push({
                            connectionType: 'horizontal-bridge',
                            bridgeY: bridgeY,
                            leftX: leftX,
                            rightX: rightX,
                            from: parentId,
                            to: 'bridge'
                        });
                        
                        sortedConnections.forEach(conn => {
                            const childCenterX = conn.toPos.x + (conn.toPos.width || 120) / 2;
                            const childTopY = conn.toPos.y;
                            
                            optimizedConnections.push({
                                ...conn,
                                connectionType: 'child-connector',
                                bridgeY: bridgeY,
                                fromX: childCenterX,
                                fromY: bridgeY,
                                toX: childCenterX,
                                toY: childTopY
                            });
                        });
                    }
                });
                
                return optimizedConnections;
            }
        }

        window.OrgChartTool.LayoutCalculator = LayoutCalculator;

    })();

    // Continue with remaining modules (ChartRenderer, ExportUtils, UIController, Main App)...
    // Due to length limitations, I'll include the key parts:

    // 5. Chart Renderer Module (simplified)
    (function() {
        'use strict';

        class ChartRenderer {
            constructor(container, options = {}) {
                this.container = container;
                this.options = { showConnections: true, ...options };
                this.svgElement = null;
                this.nodes = new Map();
                this.connections = [];
            }

            render(organizations, layout) {
                console.log(`[RENDER] Starting render: ${organizations?.length || 0} organizations`);
                
                if (!organizations || organizations.length === 0) {
                    this.showEmptyState();
                    return;
                }

                if (!layout) {
                    this.showErrorState('Layout data is missing');
                    return;
                }

                try {
                    this.clearContainer();
                    this.createSVGElement(layout);
                    this.renderOrganizations(organizations, layout);
                    
                    if (this.options.showConnections && layout.connections) {
                        this.renderConnections(layout.connections);
                    }
                    
                    console.log('[RENDER] Rendering completed successfully');
                    console.log('[RENDER] SVG element exists:', !!this.svgElement);
                    console.log('[RENDER] SVG children count:', this.svgElement?.children?.length);
                    console.log('[RENDER] Container children count:', this.container?.children?.length);
                } catch (error) {
                    console.error('[RENDER] Chart rendering failed:', error);
                    this.showErrorState(error.message);
                }
            }

            clearContainer() {
                if (this.container) {
                    // Clear only the chart-content, keep chart-controls
                    const chartContent = this.container.querySelector('.chart-content');
                    if (chartContent) {
                        chartContent.innerHTML = '';
                    }
                    this.nodes.clear();
                    this.connections = [];
                }
            }

            createSVGElement(layout) {
                console.log('[RENDER] Creating SVG element');
                console.log('[RENDER] Container:', this.container);
                console.log('[RENDER] Container visible:', this.container?.offsetWidth, 'x', this.container?.offsetHeight);
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                
                const layoutWidth = layout.bounds?.width || 1200;
                const layoutHeight = layout.bounds?.height || 800;
                
                console.log('[RENDER] Layout bounds:', layoutWidth, 'x', layoutHeight);
                
                svg.setAttribute('viewBox', `0 0 ${layoutWidth} ${layoutHeight + 100}`);
                svg.classList.add('org-chart-svg');
                
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                this.createArrowMarkers(defs);
                svg.appendChild(defs);
                
                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                mainGroup.classList.add('main-group');
                mainGroup.setAttribute('transform', 'translate(0, 80)');
                svg.appendChild(mainGroup);
                
                const chartContent = this.container.querySelector('.chart-content');
                if (chartContent) {
                    chartContent.appendChild(svg);
                } else {
                    this.container.appendChild(svg);
                }
                this.svgElement = svg;
                
                console.log('[RENDER] SVG created and appended');
                console.log('[RENDER] SVG dimensions:', svg.getAttribute('viewBox'));
            }

            createArrowMarkers(defs) {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygon.setAttribute('fill', '#666');
                
                marker.appendChild(polygon);
                defs.appendChild(marker);
            }

            renderOrganizations(organizations, layout) {
                console.log('[RENDER] Starting renderOrganizations');
                console.log('[RENDER] Organizations data:', organizations?.length);
                console.log('[RENDER] Layout nodes:', layout?.nodes?.length);
                
                // Store layout config for use in other methods
                this.currentLayout = layout;
                
                const mainGroup = this.svgElement.querySelector('.main-group');
                console.log('[RENDER] Main group found:', !!mainGroup);
                
                if (layout.nodes && layout.nodes.length > 0) {
                    console.log('[RENDER] Processing', layout.nodes.length, 'nodes');
                    layout.nodes.forEach((node, index) => {
                        const orgData = node.data;
                        console.log(`[RENDER] Node ${index}:`, node.id, orgData?.teamName);
                        if (orgData) {
                            const position = { x: node.x, y: node.y, width: node.width, height: node.height };
                            console.log(`[RENDER] Position for ${orgData.teamName}:`, position);
                            const orgElement = this.createOrganizationBox(orgData, position);
                            mainGroup.appendChild(orgElement);
                            this.nodes.set(node.id, { element: orgElement, data: orgData, position });
                            console.log(`[RENDER] Created and appended box for ${orgData.teamName}`);
                        } else {
                            console.warn(`[RENDER] No data for node ${index}:`, node);
                        }
                    });
                    console.log('[RENDER] All nodes processed');
                } else {
                    console.warn('[RENDER] No layout nodes found');
                    console.log('[RENDER] Layout structure:', layout);
                }
            }

            createWrappedText(text, x, y, maxWidth, style, color, align = 'middle') {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                if (!text || text.trim() === '') {
                    return { element: group, height: 0 };
                }
                
                console.log(`[TEXT-WRAP] Processing text: "${text}", maxWidth: ${maxWidth}`);
                
                const words = text.toString().split(/\s+/);
                const lineHeight = parseInt(style.size) * 1.2;
                let currentLine = '';
                let lineCount = 0;
                let testY = y;
                
                // Create a temporary SVG and text element for accurate measurement
                const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempSvg.style.position = 'absolute';
                tempSvg.style.left = '-9999px';
                tempSvg.style.top = '-9999px';
                tempSvg.setAttribute('width', '1000');
                tempSvg.setAttribute('height', '100');
                
                const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                tempText.setAttribute('font-family', style.family);
                tempText.setAttribute('font-size', style.size);
                tempText.setAttribute('font-weight', style.weight);
                
                tempSvg.appendChild(tempText);
                document.body.appendChild(tempSvg);
                
                words.forEach((word, index) => {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    tempText.textContent = testLine;
                    
                    // Force a layout refresh and get text width
                    tempSvg.getBoundingClientRect();
                    const bbox = tempText.getBBox();
                    const textWidth = bbox.width;
                    
                    console.log(`[TEXT-WRAP] Testing line: "${testLine}", width: ${textWidth}, max: ${maxWidth}`);
                    
                    if (textWidth > maxWidth && currentLine !== '') {
                        console.log(`[TEXT-WRAP] Breaking line: "${currentLine}" (width: ${textWidth} > ${maxWidth})`);
                        // Create line with current text
                        const textElement = this.createTextElement(
                            currentLine,
                            x,
                            testY,
                            style,
                            color
                        );
                        textElement.setAttribute('text-anchor', align);
                        group.appendChild(textElement);
                        
                        testY += lineHeight;
                        lineCount++;
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                    
                    // Handle last word
                    if (index === words.length - 1) {
                        const textElement = this.createTextElement(
                            currentLine,
                            x,
                            testY,
                            style,
                            color
                        );
                        textElement.setAttribute('text-anchor', align);
                        group.appendChild(textElement);
                        lineCount++;
                    }
                });
                
                document.body.removeChild(tempSvg);
                
                const totalHeight = lineCount * lineHeight;
                console.log(`[TEXT-WRAP] Final result: ${lineCount} lines, total height: ${totalHeight}`);
                return { element: group, height: totalHeight };
            }

            createOrganizationBox(org, position) {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.classList.add('org-box');
                group.setAttribute('data-org-id', org.id);
                group.setAttribute('transform', `translate(${position.x}, ${position.y})`);
                
                // Get layout config for sizing and fonts
                const layoutConfig = this.currentLayout?.config || {};
                const boxConfig = layoutConfig.boxConfig || { width: '138px', height: '160px' };
                const fontConfig = layoutConfig.fontConfig || { size: '12px', headerSize: '13px' };
                const teamNamesOnly = layoutConfig.teamNamesOnly || false;
                
                const width = position.width || parseInt(boxConfig.width) || 138;
                let height = position.height || parseInt(boxConfig.height) || 160;
                const headerHeight = 40;
                const padding = 8;
                const textMaxWidth = width - (padding * 2);
                
                const customBorderColor = org.borderColor || (org.colors && org.colors.borderColor) || '#000000';
                const customHeaderBg = org.headerBgColor || (org.colors && org.colors.headerBgColor) || '#f5f5f5';
                const customTextColor = org.headerTextColor || (org.colors && org.colors.headerTextColor) || '#000000';
                
                // Calculate content heights first
                let contentHeight = headerHeight + padding;
                let textElements = [];
                
                // Header text (team name) - center aligned
                if (org.teamName) {
                    const teamTextResult = this.createWrappedText(
                        org.teamName,
                        width / 2,
                        headerHeight / 2 + 6,
                        textMaxWidth,
                        { family: 'Arial, sans-serif', size: fontConfig.headerSize, weight: 'bold' },
                        customTextColor,
                        'middle'
                    );
                    textElements.push({ element: teamTextResult.element, isHeader: true });
                }
                
                // Role text - left aligned, gray color (skip if teamNamesOnly)
                if (org.role && !teamNamesOnly) {
                    const roleTextResult = this.createWrappedText(
                        org.role,
                        padding,
                        contentHeight + parseInt(fontConfig.size),
                        textMaxWidth,
                        { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'normal' },
                        '#666666',
                        'start'
                    );
                    textElements.push({ element: roleTextResult.element, height: roleTextResult.height });
                    contentHeight += roleTextResult.height + padding;
                }
                
                // Name text - center aligned, with opacity for concurrent roles (skip if teamNamesOnly)
                if (org.picName && !teamNamesOnly) {
                    const isConcurrent = org.concurrent === true || org.concurrent === 'true' || org.concurrent === 1 || org.concurrent === 'Y' || (org.concurrent && org.concurrent !== '' && org.concurrent !== 'N');
                    const nameColor = '#1976d2';
                    
                    // Add brackets for concurrent roles
                    const displayName = isConcurrent ? `(${org.picName})` : org.picName;
                    
                    const nameTextResult = this.createWrappedText(
                        displayName,
                        width / 2,
                        contentHeight + parseInt(fontConfig.size),
                        textMaxWidth,
                        { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'bold' },
                        nameColor,
                        'middle'
                    );
                    
                    // Apply transparency for concurrent roles
                    if (isConcurrent) {
                        nameTextResult.element.style.opacity = '0.8'; // 20% reduction = 80% opacity
                    }
                    
                    textElements.push({ element: nameTextResult.element, height: nameTextResult.height });
                    contentHeight += nameTextResult.height + padding;
                }
                
                // Add advisors (similar layout to team leader) (skip if teamNamesOnly)
                if (org.advisors && org.advisors.length > 0 && !teamNamesOnly) {
                    org.advisors.forEach(advisor => {
                        // Advisor role - left aligned, gray color
                        if (advisor.role) {
                            const advisorRoleResult = this.createWrappedText(
                                advisor.role,
                                padding,
                                contentHeight + parseInt(fontConfig.size),
                                textMaxWidth,
                                { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'normal' },
                                '#666666',
                                'start'
                            );
                            textElements.push({ element: advisorRoleResult.element, height: advisorRoleResult.height });
                            contentHeight += advisorRoleResult.height + 2;
                        }
                        
                        // Advisor name - center aligned, with opacity for concurrent roles
                        if (advisor.picName) {
                            const isConcurrent = advisor.concurrent === true || advisor.concurrent === 'true' || advisor.concurrent === 1 || advisor.concurrent === 'Y' || (advisor.concurrent && advisor.concurrent !== '' && advisor.concurrent !== 'N');
                            const advisorNameColor = '#1976d2';
                            
                            // Add brackets for concurrent roles
                            const displayName = isConcurrent ? `(${advisor.picName})` : advisor.picName;
                            
                            const advisorNameResult = this.createWrappedText(
                                displayName,
                                width / 2,
                                contentHeight + parseInt(fontConfig.size),
                                textMaxWidth,
                                { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'bold' },
                                advisorNameColor,
                                'middle'
                            );
                            
                            // Apply transparency for concurrent roles
                            if (isConcurrent) {
                                advisorNameResult.element.style.opacity = '0.8';
                            }
                            
                            textElements.push({ element: advisorNameResult.element, height: advisorNameResult.height });
                            contentHeight += advisorNameResult.height + padding;
                        }
                    });
                }
                
                // Add team members (non-boss members of the same team) - similar layout to team leader (skip if teamNamesOnly)
                if (org.teamMembers && org.teamMembers.length > 0 && !teamNamesOnly) {
                    org.teamMembers.forEach(member => {
                        // Member role - left aligned, gray color
                        if (member.role) {
                            const memberRoleResult = this.createWrappedText(
                                member.role,
                                padding,
                                contentHeight + parseInt(fontConfig.size),
                                textMaxWidth,
                                { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'normal' },
                                '#666666',
                                'start'
                            );
                            textElements.push({ element: memberRoleResult.element, height: memberRoleResult.height });
                            contentHeight += memberRoleResult.height + 2;
                        }
                        
                        // Member name - center aligned, with opacity for concurrent roles
                        if (member.picName) {
                            const isConcurrent = member.concurrent === true || member.concurrent === 'true' || member.concurrent === 1 || member.concurrent === 'Y' || (member.concurrent && member.concurrent !== '' && member.concurrent !== 'N');
                            const memberNameColor = '#1976d2';
                            
                            // Add brackets for concurrent roles
                            const displayName = isConcurrent ? `(${member.picName})` : member.picName;
                            
                            const memberNameResult = this.createWrappedText(
                                displayName,
                                width / 2,
                                contentHeight + parseInt(fontConfig.size),
                                textMaxWidth,
                                { family: 'Arial, sans-serif', size: fontConfig.size, weight: 'bold' },
                                memberNameColor,
                                'middle'
                            );
                            
                            // Apply transparency for concurrent roles
                            if (isConcurrent) {
                                memberNameResult.element.style.opacity = '0.8';
                            }
                            
                            textElements.push({ element: memberNameResult.element, height: memberNameResult.height });
                            contentHeight += memberNameResult.height + padding;
                        }
                    });
                }
                
                // Adjust box height and create appropriate background based on mode
                if (teamNamesOnly) {
                    // For team names only mode, use only header height
                    height = headerHeight;
                    
                    // Create only header background (no main box background)
                    const headerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    headerRect.setAttribute('width', width);
                    headerRect.setAttribute('height', headerHeight);
                    headerRect.setAttribute('x', 0);
                    headerRect.setAttribute('y', 0);
                    headerRect.setAttribute('rx', 6);
                    headerRect.setAttribute('ry', 6);
                    headerRect.setAttribute('fill', customHeaderBg);
                    headerRect.setAttribute('stroke', customBorderColor);
                    headerRect.setAttribute('stroke-width', 2);
                    group.appendChild(headerRect);
                } else {
                    // Normal mode - full box with header
                    const minHeight = parseInt(boxConfig.height) || 160;
                    height = Math.max(minHeight, contentHeight + padding);
                    
                    // Create box background
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('width', width);
                    rect.setAttribute('height', height);
                    rect.setAttribute('x', 0);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('rx', 8);
                    rect.setAttribute('ry', 8);
                    rect.setAttribute('fill', '#ffffff');
                    rect.setAttribute('stroke', customBorderColor);
                    rect.setAttribute('stroke-width', 2);
                    group.appendChild(rect);
                    
                    // Create header background
                    const headerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    headerRect.setAttribute('width', width - 4);
                    headerRect.setAttribute('height', headerHeight);
                    headerRect.setAttribute('x', 2);
                    headerRect.setAttribute('y', 2);
                    headerRect.setAttribute('rx', 6);
                    headerRect.setAttribute('ry', 6);
                    headerRect.setAttribute('fill', customHeaderBg);
                    group.appendChild(headerRect);
                }
                
                // Add all text elements
                textElements.forEach(textEl => {
                    group.appendChild(textEl.element);
                });
                
                // Store the actual height for layout calculations
                group.setAttribute('data-actual-height', height);
                
                return group;
            }

            createTextElement(text, x, y, style, color) {
                const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textElement.setAttribute('x', x);
                textElement.setAttribute('y', y);
                textElement.setAttribute('font-family', style.family || '"Segoe UI", "Yu Gothic", "Meiryo", sans-serif');
                textElement.setAttribute('font-size', style.size || '12px');
                textElement.setAttribute('font-weight', style.weight || 'normal');
                textElement.setAttribute('fill', color || '#333333');
                textElement.textContent = text;
                return textElement;
            }

            renderConnections(connections) {
                const mainGroup = this.svgElement.querySelector('.main-group');
                const connectionGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                connectionGroup.classList.add('connections');
                
                mainGroup.insertBefore(connectionGroup, mainGroup.firstChild);
                
                connections.forEach(conn => {
                    const line = this.createConnectionLine(conn);
                    if (line) {
                        connectionGroup.appendChild(line);
                        this.connections.push({ element: line, data: conn });
                    }
                });
            }

            createConnectionLine(connection) {
                if (connection.connectionType === 'horizontal-bridge') {
                    return this.createHorizontalBridge(connection);
                }
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathData = this.calculateConnectionPath(connection);
                
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#666');
                path.setAttribute('stroke-width', 2);
                path.setAttribute('fill', 'none');
                path.classList.add('connection-line');
                
                return path;
            }
            
            createHorizontalBridge(connection) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathData = `M ${connection.leftX} ${connection.bridgeY} L ${connection.rightX} ${connection.bridgeY}`;
                
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#666');
                path.setAttribute('stroke-width', 2);
                path.setAttribute('fill', 'none');
                path.classList.add('connection-line');
                
                return path;
            }

            calculateConnectionPath(connection) {
                if (connection.connectionType === 'parent-to-children') {
                    return `M ${connection.fromX} ${connection.fromY} L ${connection.toX} ${connection.toY}`;
                } else if (connection.connectionType === 'child-connector') {
                    return `M ${connection.fromX} ${connection.fromY} L ${connection.toX} ${connection.toY}`;
                } else if (connection.fromPos && connection.toPos) {
                    // Check if we're in team names only mode
                    const layoutConfig = this.currentLayout?.config || {};
                    const teamNamesOnly = layoutConfig.teamNamesOnly || false;
                    
                    // Adjust heights based on mode
                    const fromHeight = teamNamesOnly ? 40 : (connection.fromPos.height || 80);
                    const toHeight = teamNamesOnly ? 40 : (connection.toPos.height || 80);
                    
                    const fromX = connection.fromPos.x + (connection.fromPos.width || 120) / 2;
                    const fromY = connection.fromPos.y + fromHeight;
                    const toX = connection.toPos.x + (connection.toPos.width || 120) / 2;
                    const toY = connection.toPos.y;
                    
                    if (Math.abs(fromX - toX) < 10) {
                        return `M ${fromX} ${fromY} L ${fromX} ${toY}`;
                    }
                    
                    const midY = fromY + (toY - fromY) * 0.5;
                    return `M ${fromX} ${fromY} L ${fromX} ${midY} L ${toX} ${midY} L ${toX} ${toY}`;
                }
                
                return '';
            }

            showEmptyState() {
                this.container.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #666;">
                        <p>No organization data available</p>
                        <p>Please load data first</p>
                    </div>
                `;
            }

            showErrorState(message) {
                this.container.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #d32f2f;">
                        <p>Error rendering organization chart</p>
                        <p>${message}</p>
                    </div>
                `;
            }

            exportSVG() {
                if (!this.svgElement) return '';
                return new XMLSerializer().serializeToString(this.svgElement);
            }
        }

        window.OrgChartTool.ChartRenderer = ChartRenderer;

    })();

    // 6. Export Utils Module
    (function() {
        'use strict';

        class ExportUtils {
            constructor() {
                this.languageManager = null;
                this.initialize();
            }

            initialize() {
                if (window.OrgChartTool?.Config?.LanguageManager) {
                    this.languageManager = window.OrgChartTool.Config.LanguageManager;
                    this.t = window.OrgChartTool.Config.t || ((key) => key);
                } else {
                    this.t = (key) => key;
                }
            }

            exportSVG(svgElement, filename = 'organization-chart.svg') {
                if (!svgElement) return;

                const clonedSVG = svgElement.cloneNode(true);
                this.embedStyles(clonedSVG);
                
                const svgData = new XMLSerializer().serializeToString(clonedSVG);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                this.downloadBlob(blob, filename);
            }

            async exportPNG(svgElement, filename = 'organization-chart.png', scale = 2) {
                if (!svgElement) return;

                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const svgData = this.prepareSVGForExport(svgElement);
                    
                    const img = new Image();
                    img.onload = () => {
                        const padding = 40;
                        canvas.width = (img.width + padding * 2) * scale;
                        canvas.height = (img.height + padding * 2) * scale;
                        ctx.scale(scale, scale);
                        
                        // Set white background (comment out for transparent)
                        // ctx.fillStyle = 'white';
                        // ctx.fillRect(0, 0, img.width + padding * 2, img.height + padding * 2);
                        
                        ctx.drawImage(img, padding, padding);
                        
                        canvas.toBlob((blob) => {
                            this.downloadBlob(blob, filename);
                        }, 'image/png');
                    };
                    
                    img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
                } catch (error) {
                    console.error('PNG export failed:', error);
                }
            }

            exportHTML(container, filename = 'organization-chart.html') {
                if (!container) return;

                const htmlContent = this.generateStandaloneHTML(container);
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                this.downloadBlob(blob, filename);
            }

            prepareSVGForExport(svgElement) {
                const clonedSVG = svgElement.cloneNode(true);
                this.embedStyles(clonedSVG);
                
                const bbox = svgElement.getBBox();
                clonedSVG.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
                clonedSVG.setAttribute('width', bbox.width);
                clonedSVG.setAttribute('height', bbox.height);
                
                return new XMLSerializer().serializeToString(clonedSVG);
            }

            embedStyles(svg) {
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    .org-box { cursor: pointer; }
                    .org-box:hover .org-box-bg { stroke-width: 3; }
                    .connection-line { stroke: #666; stroke-width: 2; fill: none; }
                    .team-name { font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif; font-weight: bold; }
                    .pic-name { font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif; }
                    .role { font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif; font-style: italic; }
                `;
                svg.insertBefore(style, svg.firstChild);
            }

            generateStandaloneHTML(container) {
                return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organization Chart</title>
    <style>
        body { font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif; margin: 20px; }
        .chart-container { width: 100%; height: 600px; border: 1px solid #ccc; }
        svg { width: 100%; height: 100%; }
        .org-box { cursor: pointer; }
        .connection-line { stroke: #666; stroke-width: 2; fill: none; }
    </style>
</head>
<body>
    <h1>Organization Chart</h1>
    <div class="export-info">
        <p>Generated on: ${new Date().toLocaleString()}</p>
    </div>
    ${container.outerHTML}
</body>
</html>`;
            }

            downloadBlob(blob, filename) {
                // Check for IE/old Edge support
                if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                    window.navigator.msSaveOrOpenBlob(blob, filename);
                    return;
                }
                
                // Modern browsers
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        window.OrgChartTool.ExportUtils = ExportUtils;

    })();

    // 7. UI Controller Module
    (function() {
        'use strict';

        class UIController {
            constructor() {
                this.languageManager = null;
                this.dataProcessor = null;
                this.layoutCalculator = null;
                this.chartRenderer = null;
                this.exportUtils = null;
                this.tableEditor = null;
                
                this.currentData = [];
                this.currentLayout = null;
                this.viewMode = 'chart';
                
                this.initialize();
            }

            initialize() {
                this.setupModuleReferences();
                this.setupEventListeners();
                this.initializeUI();
                this.loadSettings();
            }

            setupModuleReferences() {
                if (window.OrgChartTool?.Config?.LanguageManager) {
                    this.languageManager = window.OrgChartTool.Config.LanguageManager;
                    this.t = window.OrgChartTool.Config.t || ((key) => key);
                } else {
                    this.t = (key) => key;
                }
                if (window.OrgChartTool?.ExportUtils) {
                    this.exportUtils = new window.OrgChartTool.ExportUtils();
                }
            }

            setupEventListeners() {
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#load-sample-btn')) {
                        this.loadSampleData();
                    } else if (e.target.matches('#generate-chart-btn')) {
                        this.generateChart();
                    } else if (e.target.matches('#toggle-view-btn')) {
                        this.toggleView();
                    } else if (e.target.matches('#export-svg-btn')) {
                        this.exportSVG();
                    } else if (e.target.matches('#export-png-btn')) {
                        this.exportPNG();
                    } else if (e.target.matches('#export-html-btn')) {
                        this.exportHTML();
                    } else if (e.target.matches('#zoom-in-btn')) {
                        this.zoomIn();
                    } else if (e.target.matches('#zoom-out-btn')) {
                        this.zoomOut();
                    } else if (e.target.matches('#zoom-reset-btn')) {
                        this.zoomReset();
                    } else if (e.target.matches('#fullscreen-btn')) {
                        this.toggleFullscreen();
                    }
                });

                document.addEventListener('change', (e) => {
                    if (e.target.matches('#file-input')) {
                        this.handleFileUpload(e.target.files[0]);
                    }
                });

                document.addEventListener('change', (e) => {
                    if (e.target.matches('#language-select')) {
                        this.changeLanguage(e.target.value);
                    } else if (e.target.matches('#box-size-select')) {
                        this.changeBoxSize(e.target.value);
                    } else if (e.target.matches('#font-size-select')) {
                        this.changeFontSize(e.target.value);
                    } else if (e.target.matches('#team-names-only')) {
                        this.changeTeamNamesOnly(e.target.checked);
                    } else if (e.target.matches('#starting-team-select')) {
                        this.changeStartingTeam(e.target.value);
                    } else if (e.target.matches('#level-limit-select')) {
                        this.changeLevelLimit(e.target.value);
                    }
                });
                
                // File Drop Zone
                const dropZone = document.getElementById('file-drop-zone');
                const fileInput = document.getElementById('file-input');
                
                dropZone.addEventListener('click', () => {
                    fileInput.click();
                });
                
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });
                
                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });

                // ESC key to exit fullscreen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const container = document.getElementById('chart-container');
                        const fullscreenBtn = document.getElementById('fullscreen-btn');
                        const tooltip = fullscreenBtn?.querySelector('.tooltip');
                        if (container && container.classList.contains('fullscreen')) {
                            container.classList.remove('fullscreen');
                            fullscreenBtn.childNodes[0].textContent = '⛶';
                            if (tooltip) {
                                tooltip.setAttribute('data-i18n', 'fullscreen');
                                tooltip.textContent = this.t('fullscreen');
                            }
                        }
                    }
                });

                // Mouse wheel zoom on chart container
                const chartContainer = document.getElementById('chart-container');
                if (chartContainer) {
                    chartContainer.addEventListener('wheel', (e) => {
                        if (e.ctrlKey) {
                            e.preventDefault();
                            const svg = document.querySelector('#chart-container svg');
                            if (svg) {
                                const transform = svg.style.transform || '';
                                const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                                const translateMatch = transform.match(/translate\(([^,)]+),?\s*([^)]*)\)/);
                                
                                const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
                                const translateX = translateMatch ? parseFloat(translateMatch[1]) || 0 : 0;
                                const translateY = translateMatch ? parseFloat(translateMatch[2]) || 0 : 0;
                                
                                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                                const newScale = Math.min(Math.max(currentScale * delta, 0.1), 3);
                                svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${newScale})`;
                                svg.style.transformOrigin = 'top left';
                                this.updateDraggableState();
                            }
                        }
                    });
                    
                    // Drag and drop functionality for zoomed chart
                    this.setupChartDragging(chartContainer);
                }
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.name.match(/\.(xlsx|xls)$/i)) {
                            this.handleFileUpload(file);
                        } else {
                            this.showNotification('Please drop an Excel file (.xlsx or .xls)', 'warning');
                        }
                    }
                });
            }

            async handleFileUpload(file) {
                if (!file) return;

                try {
                    this.showLoadingState(true);
                    
                    if (!this.dataProcessor) {
                        this.dataProcessor = new window.OrgChartTool.DataProcessor();
                    }
                    
                    await this.dataProcessor.processExcelFile(file);
                    this.currentData = Array.from(this.dataProcessor.getProcessedData().organizations.values());
                    this.updateButtonStates();
                    this.updateStartingTeamOptions();
                    
                    this.showNotification('File loaded successfully', 'success');
                    
                    // Automatically show table view after loading file
                    if (this.viewMode === 'chart') {
                        this.toggleView();
                    }
                } catch (error) {
                    console.error('File upload error:', error);
                    this.showNotification('File load failed: ' + error.message, 'error');
                } finally {
                    this.showLoadingState(false);
                }
            }

            loadSampleData() {
                try {
                    if (!this.dataProcessor) {
                        this.dataProcessor = new window.OrgChartTool.DataProcessor();
                    }
                    this.dataProcessor.loadSampleData();
                    this.currentData = Array.from(this.dataProcessor.getProcessedData().organizations.values());
                    this.updateButtonStates();
                    this.updateStartingTeamOptions();
                    this.showNotification('Sample data loaded', 'success');
                    
                    // Automatically show table view after loading sample data
                    if (this.viewMode === 'chart') {
                        this.toggleView();
                    }
                } catch (error) {
                    console.error('Sample data load error:', error);
                    this.showNotification('Sample data load failed', 'error');
                }
            }
            
            exportEmptyTable() {
                try {
                    // Create empty table data with headers only
                    const emptyData = [
                        ['Level', 'Team Name', 'Exact Team Name', 'Upper Team', 'Team ID', 
                         'Role', 'Role (2nd Lang)', 'Team Boss', 'PIC Name', 'PIC Name (2nd Lang)',
                         'Concurrent', 'Employee CD', 'Grade', 'Memo',
                         'Border Color', 'Header BG Color', 'Header Text Color']
                    ];
                    
                    // Add one sample row to show format
                    emptyData.push([
                        '1', 'Headquarters', 'Corporate Headquarters', 'TOP', 'HQ001',
                        'President & CEO', '代表取締役社長', 'Y', 'John Doe', 'ジョン・ドー',
                        'N', '001', 'CEO', 'Sample entry',
                        '#000000', '#e3f2fd', '#000000'
                    ]);
                    
                    this.exportToExcel(emptyData, 'organization_chart_template.xlsx');
                    this.showNotification('Empty table template exported', 'success');
                } catch (error) {
                    console.error('Empty table export error:', error);
                    this.showNotification('Export failed', 'error');
                }
            }
            
            exportCurrentData() {
                try {
                    // Check if there's current data to export
                    if (!this.dataProcessor || !this.dataProcessor.getRawData() || this.dataProcessor.getRawData().length === 0) {
                        this.showNotification('No data to export. Please load data first.', 'warning');
                        return;
                    }
                    
                    // Get current raw data from dataProcessor
                    const currentData = this.dataProcessor.getRawData();
                    const headers = [
                        'Level', 'Team Name', 'Exact Team Name', 'Upper Team', 'Team ID', 
                        'Role', 'Role (2nd Lang)', 'Team Boss', 'PIC Name', 'PIC Name (2nd Lang)',
                        'Concurrent', 'Employee CD', 'Grade', 'Memo',
                        'Border Color', 'Header BG Color', 'Header Text Color'
                    ];
                    
                    const exportData = [headers, ...currentData];
                    const filename = `organization_chart_${new Date().toISOString().slice(0, 10)}.xlsx`;
                    this.exportToExcel(exportData, filename);
                    this.showNotification('Current data exported successfully', 'success');
                } catch (error) {
                    console.error('Current data export error:', error);
                    this.showNotification('Export failed', 'error');
                }
            }
            
            exportToExcel(data, filename) {
                const ws = XLSX.utils.aoa_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Organization Chart');
                
                // Set column widths
                const colWidths = [
                    {wch: 8},  // Level
                    {wch: 20}, // Team Name
                    {wch: 25}, // Exact Team Name
                    {wch: 20}, // Upper Team
                    {wch: 12}, // Team ID
                    {wch: 25}, // Role
                    {wch: 25}, // Role (2nd Lang)
                    {wch: 10}, // Team Boss
                    {wch: 20}, // PIC Name
                    {wch: 20}, // PIC Name (2nd Lang)
                    {wch: 10}, // Concurrent
                    {wch: 15}, // Employee CD
                    {wch: 10}, // Grade
                    {wch: 30}, // Memo
                    {wch: 12}, // Border Color
                    {wch: 15}, // Header BG Color
                    {wch: 15}  // Header Text Color
                ];
                ws['!cols'] = colWidths;
                
                // Use blob approach for better compatibility
                const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                
                // Use the same downloadBlob method as other exports
                window.OrgChartTool.exportUtils.downloadBlob(blob, filename);
            }

            generateChart() {
                if (!this.currentData || this.currentData.length === 0) {
                    this.showNotification('No data available', 'warning');
                    return;
                }

                try {
                    this.showLoadingState(true);

                    // Get chart generation options
                    const startingTeam = document.getElementById('starting-team-select').value || '';
                    const levelLimit = parseInt(document.getElementById('level-limit-select').value) || 0;
                    const teamNamesOnly = document.getElementById('team-names-only').checked;
                    
                    // Filter data based on starting team and level limit
                    let filteredData = this.filterDataForChart(null, startingTeam, levelLimit);
                    
                    // Convert filtered raw data to processed format for LayoutCalculator
                    const processedFilteredData = this.convertRawDataToProcessedFormat(filteredData);
                    console.log('[CHART] Processed filtered data for rendering:', processedFilteredData?.length);

                    if (!this.layoutCalculator) {
                        this.layoutCalculator = new window.OrgChartTool.LayoutCalculator();
                    }
                    const options = {
                        fontSize: document.getElementById('font-size-select').value,
                        boxSize: document.getElementById('box-size-select').value,
                        teamNamesOnly: teamNamesOnly
                    };
                    this.currentLayout = this.layoutCalculator.calculateLayout(processedFilteredData, null, options);

                    if (!this.chartRenderer) {
                        const container = document.querySelector('#chart-container');
                        this.chartRenderer = new window.OrgChartTool.ChartRenderer(container);
                    }
                    this.chartRenderer.render(processedFilteredData, this.currentLayout);

                    // Add team name comparison table
                    this.addTeamNameComparisonTable(processedFilteredData);

                    // Ensure chart view is displayed
                    this.ensureChartViewVisible();

                    this.updateButtonStates();
                    this.showNotification(`Chart generated (${processedFilteredData.length} organizations)`, 'success');
                } catch (error) {
                    console.error('Chart generation error:', error);
                    this.showNotification('Chart generation failed: ' + error.message, 'error');
                } finally {
                    this.showLoadingState(false);
                }
            }

            filterDataForChart(data, startingTeam, levelLimit) {
                // Use existing dataProcessor to get raw data
                const rawData = this.dataProcessor.getRawData();
                if (!rawData || rawData.length === 0) {
                    throw new Error('No raw data available for filtering');
                }

                if (!startingTeam && levelLimit === 0) {
                    return rawData; // No filtering needed, return full raw data
                }
                
                const processedData = this.dataProcessor.getProcessedData();

                let filteredOrgs = new Set();
                
                // Find starting organization
                let startingOrg = null;
                if (startingTeam) {
                    for (let [orgId, org] of processedData.organizations) {
                        if (org.teamName === startingTeam) {
                            startingOrg = org;
                            break;
                        }
                    }
                    if (!startingOrg) {
                        console.warn(`Starting team "${startingTeam}" not found in processed data`);
                        console.log('Available teams:', Array.from(processedData.organizations.values()).map(o => o.teamName));
                        throw new Error(`Starting team "${startingTeam}" not found`);
                    }
                } else {
                    // Find TOP level organization
                    for (let [orgId, org] of processedData.organizations) {
                        if (org.upperTeam === 'TOP' || !org.upperTeam) {
                            startingOrg = org;
                            break;
                        }
                    }
                }

                if (!startingOrg) {
                    throw new Error('No starting organization found');
                }

                // Add starting organization
                filteredOrgs.add(startingOrg.teamName);

                // Recursively add child organizations within level limit
                const addChildOrganizations = (parentTeamName, currentLevel) => {
                    if (levelLimit > 0 && currentLevel >= levelLimit) {
                        return; // Reached level limit
                    }

                    for (let [orgId, org] of processedData.organizations) {
                        if (org.upperTeam === parentTeamName && !filteredOrgs.has(org.teamName)) {
                            filteredOrgs.add(org.teamName);
                            addChildOrganizations(org.teamName, currentLevel + 1);
                        }
                    }
                };

                addChildOrganizations(startingOrg.teamName, 1);

                // Filter original raw data array
                const result = rawData.filter(row => {
                    const teamName = row[1]; // teamName is at index 1
                    return filteredOrgs.has(teamName);
                });
                
                console.log(`Filtered organizations: ${filteredOrgs.size} teams, ${result.length} rows`);
                console.log('Filtered teams:', Array.from(filteredOrgs));
                
                if (result.length === 0) {
                    throw new Error('No organizations found after filtering');
                }
                
                return result;
            }

            normalizeSubsetLevels(rawData, startingTeam) {
                console.log(`[NORMALIZE] Normalizing levels for starting team: ${startingTeam}`);
                
                // Create a map of team names to their rows
                const teamRowMap = new Map();
                rawData.forEach(row => {
                    teamRowMap.set(row[1], row); // teamName is at index 1
                });
                
                // Find the starting team row
                const startingRow = teamRowMap.get(startingTeam);
                if (!startingRow) {
                    console.error(`Starting team ${startingTeam} not found in raw data`);
                    return rawData;
                }
                
                // Build parent-child relationships from the filtered data
                const parentChildMap = new Map();
                const childParentMap = new Map();
                rawData.forEach(row => {
                    const teamName = row[1];
                    const upperTeam = row[3]; // upperTeam is at index 3
                    
                    if (upperTeam && teamRowMap.has(upperTeam)) {
                        // Only include relationships where both parent and child are in filtered data
                        if (!parentChildMap.has(upperTeam)) {
                            parentChildMap.set(upperTeam, []);
                        }
                        parentChildMap.get(upperTeam).push(teamName);
                        childParentMap.set(teamName, upperTeam);
                    }
                });
                
                // Calculate new levels starting from 1 for the starting team
                const newLevels = new Map();
                const calculateLevel = (teamName, level) => {
                    if (newLevels.has(teamName)) return;
                    
                    newLevels.set(teamName, level);
                    console.log(`[NORMALIZE] ${teamName} -> level ${level}`);
                    
                    // Recursively assign levels to children
                    const children = parentChildMap.get(teamName) || [];
                    children.forEach(child => {
                        calculateLevel(child, level + 1);
                    });
                };
                
                // Start calculation from the starting team at level 1
                calculateLevel(startingTeam, 1);
                
                // Update raw data with new levels and adjust upperTeam relationships
                const normalizedData = rawData.map(row => {
                    const teamName = row[1];
                    const newLevel = newLevels.get(teamName);
                    if (newLevel !== undefined) {
                        const newRow = [...row];
                        newRow[0] = newLevel; // Update level at index 0
                        
                        // Update upperTeam to maintain hierarchy in subset
                        if (newLevel === 1) {
                            // Starting team should have no upper team or "TOP"
                            newRow[3] = '';
                        } else {
                            // Keep existing upperTeam if it exists in the subset
                            const currentUpperTeam = row[3];
                            if (currentUpperTeam && newLevels.has(currentUpperTeam)) {
                                newRow[3] = currentUpperTeam;
                            } else {
                                // If upperTeam is not in subset, clear it
                                newRow[3] = '';
                            }
                        }
                        
                        return newRow;
                    }
                    return row;
                });
                
                console.log(`[NORMALIZE] Normalized ${normalizedData.length} rows with proper hierarchy`);
                return normalizedData;
            }

            convertRawDataToProcessedFormat(rawData) {
                console.log('[CONVERT] Converting raw data to processed format');
                console.log('[CONVERT] Input rows:', rawData?.length);
                
                if (!rawData || rawData.length === 0) {
                    return [];
                }
                
                // Check if we're dealing with a subset starting from a specific team
                const startingTeam = document.getElementById('starting-team-select').value || '';
                
                if (startingTeam) {
                    // Normalize levels to start from 1 for the starting team
                    console.log('[CONVERT] Before normalization:', rawData.slice(0, 3));
                    rawData = this.normalizeSubsetLevels(rawData, startingTeam);
                    console.log('[CONVERT] After normalization:', rawData.slice(0, 3));
                }

                // Create a temporary DataProcessor to convert the data
                const tempProcessor = new window.OrgChartTool.DataProcessor();
                tempProcessor.rawData = rawData; // Set the raw data directly
                console.log('[CONVERT] Data passed to DataProcessor:', rawData.length, 'rows');
                tempProcessor.processData(); // Then process it
                const processedData = tempProcessor.getProcessedData();
                
                // Convert Map to Array of organization objects
                const result = Array.from(processedData.organizations.values());
                console.log('[CONVERT] Output organizations:', result?.length);
                console.log('[CONVERT] First converted org:', result?.[0]);
                
                return result;
            }

            ensureChartViewVisible() {
                const chartContainer = document.getElementById('chart-container');
                const tableContainer = document.getElementById('table-container');
                const toggleBtn = document.getElementById('toggle-view-btn');
                
                console.log('[VIEW] Ensuring chart view is visible');
                console.log('[VIEW] Chart container display:', chartContainer?.style.display);
                console.log('[VIEW] Table container display:', tableContainer?.style.display);
                
                if (chartContainer && tableContainer) {
                    chartContainer.style.display = 'block';
                    tableContainer.style.display = 'none';
                    this.viewMode = 'chart';
                    
                    if (toggleBtn) {
                        toggleBtn.textContent = this.t('toggleView');
                    }
                    
                    console.log('[VIEW] Switched to chart view');
                    console.log('[VIEW] Chart container final display:', chartContainer.style.display);
                }
            }

            toggleView() {
                const chartContainer = document.getElementById('chart-container');
                const tableContainer = document.getElementById('table-container');
                const toggleBtn = document.getElementById('toggle-view-btn');
                
                if (chartContainer.style.display === 'none') {
                    chartContainer.style.display = 'block';
                    tableContainer.style.display = 'none';
                    toggleBtn.textContent = this.t('toggleView');
                } else {
                    chartContainer.style.display = 'none';
                    tableContainer.style.display = 'block';
                    toggleBtn.textContent = 'Show Chart';
                    this.showTableView();
                }
            }

            showTableView() {
                const tableContainer = document.getElementById('table-container');
                if (!this.dataProcessor || !this.dataProcessor.getRawData().length) {
                    tableContainer.innerHTML = '<p>No data available</p>';
                    return;
                }

                if (!this.tableEditor) {
                    this.tableEditor = new window.OrgChartTool.TableEditor(tableContainer);
                    window.OrgChartTool.tableEditor = this.tableEditor; // For event handlers
                }
                
                this.tableEditor.render(this.dataProcessor.getRawData());
            }

            updateDataFromTable(tableData) {
                if (!this.dataProcessor) {
                    this.dataProcessor = new window.OrgChartTool.DataProcessor();
                }
                
                this.dataProcessor.updateFromTableData(tableData);
                this.currentData = Array.from(this.dataProcessor.getProcessedData().organizations.values());
                
                // Switch back to chart view and regenerate
                const chartContainer = document.getElementById('chart-container');
                const tableContainer = document.getElementById('table-container');
                chartContainer.style.display = 'block';
                tableContainer.style.display = 'none';
                
                this.generateChart();
                this.showNotification('Changes applied successfully', 'success');
            }

            changeLanguage(language) {
                if (this.languageManager) {
                    this.languageManager.setLanguage(language);
                    this.updateUIText();
                    
                    // Update table if it's currently displayed
                    if (this.tableEditor && this.tableEditor.isActive()) {
                        this.tableEditor.render(this.tableEditor.getTableDataAsRaw());
                    }
                    
                    this.saveSettings();
                }
            }

            changeBoxSize(size) {
                if (this.currentData.length > 0) {
                    this.generateChart();
                }
                this.saveSettings();
            }

            updateStartingTeamOptions() {
                const select = document.getElementById('starting-team-select');
                if (!select || !this.currentData) return;

                // Clear existing options except TOP
                select.innerHTML = '<option value="">TOP</option>';

                // Get all team names from current data
                const teams = new Set();
                if (this.dataProcessor && this.dataProcessor.getRawData) {
                    const rawData = this.dataProcessor.getRawData();
                    rawData.forEach(row => {
                        const teamName = row[1]; // teamName is at index 1
                        if (teamName && teamName !== 'TOP') {
                            teams.add(teamName);
                        }
                    });
                }

                // Sort teams alphabetically
                const sortedTeams = Array.from(teams).sort();

                // Add team options
                sortedTeams.forEach(teamName => {
                    const option = document.createElement('option');
                    option.value = teamName;
                    option.textContent = teamName;
                    select.appendChild(option);
                });
            }

            changeFontSize(size) {
                if (this.currentData.length > 0) {
                    this.generateChart();
                }
                this.saveSettings();
            }

            changeTeamNamesOnly(checked) {
                if (this.currentData.length > 0) {
                    this.generateChart();
                }
                this.saveSettings();
            }

            changeStartingTeam(value) {
                if (this.currentData.length > 0) {
                    this.generateChart();
                }
                this.saveSettings();
            }

            changeLevelLimit(value) {
                if (this.currentData.length > 0) {
                    this.generateChart();
                }
                this.saveSettings();
            }

            addTeamNameComparisonTable(organizations) {
                // Remove existing comparison table if any
                const existingTable = document.getElementById('team-name-comparison');
                if (existingTable) {
                    existingTable.remove();
                }

                // Collect team name pairs where they differ
                const teamNamePairs = [];
                organizations.forEach(org => {
                    if (org.teamName && org.exactTeamName && org.teamName !== org.exactTeamName) {
                        teamNamePairs.push({
                            teamName: org.teamName,
                            exactTeamName: org.exactTeamName
                        });
                    }
                });

                // Remove duplicates and sort alphabetically by team name
                const uniquePairs = [];
                const seen = new Set();
                teamNamePairs.forEach(pair => {
                    const key = `${pair.teamName}|${pair.exactTeamName}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniquePairs.push(pair);
                    }
                });
                uniquePairs.sort((a, b) => a.teamName.localeCompare(b.teamName));

                // Only create table if there are differences
                if (uniquePairs.length === 0) {
                    return;
                }

                // Create table
                const tableContainer = document.createElement('div');
                tableContainer.id = 'team-name-comparison';
                tableContainer.style.cssText = `
                    margin-top: 20px;
                    padding: 15px;
                    background: #f8f9fa;
                    border-radius: 6px;
                    border: 1px solid #e5e7eb;
                `;

                const title = document.createElement('h3');
                title.textContent = this.t('teamNameComparison');
                title.style.cssText = `
                    margin: 0 0 10px 0;
                    font-size: 16px;
                    color: #374151;
                `;

                const table = document.createElement('table');
                table.style.cssText = `
                    width: 100%;
                    border-collapse: collapse;
                    font-size: 14px;
                `;

                // Table header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['teamNameShort', 'teamNameFull'].forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = this.t(key);
                    th.style.cssText = `
                        padding: 8px 12px;
                        border: 1px solid #d1d5db;
                        background: #f3f4f6;
                        font-weight: 600;
                        text-align: left;
                    `;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement('tbody');
                uniquePairs.forEach(pair => {
                    const row = document.createElement('tr');
                    [pair.teamName, pair.exactTeamName].forEach(text => {
                        const td = document.createElement('td');
                        td.textContent = text;
                        td.style.cssText = `
                            padding: 8px 12px;
                            border: 1px solid #d1d5db;
                            background: white;
                        `;
                        row.appendChild(td);
                    });
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);

                tableContainer.appendChild(title);
                tableContainer.appendChild(table);

                // Insert after chart container
                const chartContainer = document.getElementById('chart-container');
                chartContainer.parentNode.insertBefore(tableContainer, chartContainer.nextSibling);
            }

            exportSVG() {
                const svg = document.querySelector('#chart-container svg');
                if (svg && this.exportUtils) {
                    this.exportUtils.exportSVG(svg);
                    this.showNotification('SVG exported', 'success');
                }
            }

            exportPNG() {
                const svg = document.querySelector('#chart-container svg');
                if (svg && this.exportUtils) {
                    this.exportUtils.exportPNG(svg);
                    this.showNotification('PNG exported', 'success');
                }
            }

            exportHTML() {
                const container = document.querySelector('#chart-container');
                if (container && this.exportUtils) {
                    this.exportUtils.exportHTML(container);
                    this.showNotification('HTML exported', 'success');
                }
            }

            initializeUI() {
                this.updateUIText();
                this.updateButtonStates();
            }

            updateUIText() {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.dataset.i18n;
                    if (this.t) {
                        element.textContent = this.t(key);
                    }
                });
            }

            updateButtonStates() {
                const hasData = this.currentData && this.currentData.length > 0;
                const hasChart = hasData && this.currentLayout;

                document.getElementById('generate-chart-btn').disabled = !hasData;
                document.getElementById('toggle-view-btn').disabled = !hasData;
                document.getElementById('export-svg-btn').disabled = !hasChart;
                document.getElementById('export-png-btn').disabled = !hasChart;
                document.getElementById('export-html-btn').disabled = !hasChart;
            }

            showLoadingState(show) {
                const loader = document.getElementById('loading');
                if (loader) {
                    loader.style.display = show ? 'block' : 'none';
                }
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            saveSettings() {
                const settings = {
                    language: this.languageManager?.getCurrentLanguage(),
                    viewMode: this.viewMode,
                    teamNamesOnly: document.getElementById('team-names-only')?.checked || false,
                    startingTeam: document.getElementById('starting-team-select')?.value || '',
                    levelLimit: document.getElementById('level-limit-select')?.value || '0'
                };
                localStorage.setItem('orgChart.settings', JSON.stringify(settings));
            }

            loadSettings() {
                try {
                    const settings = JSON.parse(localStorage.getItem('orgChart.settings') || '{}');
                    if (settings.language && this.languageManager) {
                        this.languageManager.setLanguage(settings.language);
                        const langSelect = document.querySelector('#language-select');
                        if (langSelect) langSelect.value = settings.language;
                    }
                    if (settings.viewMode) {
                        this.viewMode = settings.viewMode;
                    }
                    if (typeof settings.teamNamesOnly === 'boolean') {
                        const checkbox = document.getElementById('team-names-only');
                        if (checkbox) checkbox.checked = settings.teamNamesOnly;
                    }
                    if (settings.startingTeam !== undefined) {
                        const startingTeamSelect = document.getElementById('starting-team-select');
                        if (startingTeamSelect) startingTeamSelect.value = settings.startingTeam;
                    }
                    if (settings.levelLimit !== undefined) {
                        const levelLimitSelect = document.getElementById('level-limit-select');
                        if (levelLimitSelect) levelLimitSelect.value = settings.levelLimit;
                    }
                } catch (error) {
                    console.error('Settings load error:', error);
                }
            }

            // Chart zoom and fullscreen functionality
            zoomIn() {
                const svg = document.querySelector('#chart-container svg');
                if (svg) {
                    const transform = svg.style.transform || '';
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    const translateMatch = transform.match(/translate\(([^,)]+),?\s*([^)]*)\)/);
                    
                    const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
                    const translateX = translateMatch ? parseFloat(translateMatch[1]) || 0 : 0;
                    const translateY = translateMatch ? parseFloat(translateMatch[2]) || 0 : 0;
                    
                    const newScale = Math.min(currentScale * 1.2, 3);
                    svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${newScale})`;
                    svg.style.transformOrigin = 'top left';
                    this.updateDraggableState();
                }
            }

            zoomOut() {
                const svg = document.querySelector('#chart-container svg');
                if (svg) {
                    const transform = svg.style.transform || '';
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    const translateMatch = transform.match(/translate\(([^,)]+),?\s*([^)]*)\)/);
                    
                    const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
                    const translateX = translateMatch ? parseFloat(translateMatch[1]) || 0 : 0;
                    const translateY = translateMatch ? parseFloat(translateMatch[2]) || 0 : 0;
                    
                    const newScale = Math.max(currentScale / 1.2, 0.1);
                    svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${newScale})`;
                    svg.style.transformOrigin = 'top left';
                    this.updateDraggableState();
                }
            }

            zoomReset() {
                const svg = document.querySelector('#chart-container svg');
                if (svg) {
                    svg.style.transform = 'translate(0px, 0px) scale(1)';
                    svg.style.transformOrigin = 'top left';
                    this.updateDraggableState();
                }
            }

            toggleFullscreen() {
                const container = document.getElementById('chart-container');
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                const tooltip = fullscreenBtn.querySelector('.tooltip');
                
                if (container.classList.contains('fullscreen')) {
                    container.classList.remove('fullscreen');
                    fullscreenBtn.childNodes[0].textContent = '⛶';
                    if (tooltip) {
                        tooltip.setAttribute('data-i18n', 'fullscreen');
                        tooltip.textContent = this.t('fullscreen');
                    }
                } else {
                    container.classList.add('fullscreen');
                    fullscreenBtn.childNodes[0].textContent = '⚙';
                    if (tooltip) {
                        tooltip.setAttribute('data-i18n', 'exitFullscreen');
                        tooltip.textContent = this.t('exitFullscreen');
                    }
                }
            }

            // Chart dragging functionality
            setupChartDragging(container) {
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let startTranslateX = 0;
                let startTranslateY = 0;

                const chartContent = container.querySelector('.chart-content');
                const dragTarget = chartContent || container;

                dragTarget.addEventListener('mousedown', (e) => {
                    const svg = container.querySelector('svg');
                    if (!svg) return;
                    
                    const currentScale = parseFloat(svg.style.transform.replace(/.*scale\(([^)]+)\).*/, '$1') || '1');
                    if (currentScale <= 1) return; // Only allow dragging when zoomed
                    
                    // Ignore if clicking on control buttons
                    if (e.target.closest('.chart-controls')) return;
                    
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Get current transform values
                    const transform = svg.style.transform || '';
                    const translateMatch = transform.match(/translate\(([^,)]+),?\s*([^)]*)\)/);
                    startTranslateX = translateMatch ? parseFloat(translateMatch[1]) || 0 : 0;
                    startTranslateY = translateMatch ? parseFloat(translateMatch[2]) || 0 : 0;
                    
                    container.classList.add('dragging');
                    svg.classList.add('dragging');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    e.preventDefault();
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    const newTranslateX = startTranslateX + deltaX;
                    const newTranslateY = startTranslateY + deltaY;
                    
                    const svg = container.querySelector('svg');
                    if (svg) {
                        const currentScale = parseFloat(svg.style.transform.replace(/.*scale\(([^)]+)\).*/, '$1') || '1');
                        svg.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${currentScale})`;
                        svg.style.transformOrigin = 'top left';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        container.classList.remove('dragging');
                        const svg = container.querySelector('svg');
                        if (svg) svg.classList.remove('dragging');
                    }
                });

                // Prevent text selection while dragging
                dragTarget.addEventListener('selectstart', (e) => {
                    if (isDragging) e.preventDefault();
                });
            }

            updateDraggableState() {
                const container = document.getElementById('chart-container');
                const svg = container?.querySelector('svg');
                if (!svg) return;
                
                const currentScale = parseFloat(svg.style.transform.replace(/.*scale\(([^)]+)\).*/, '$1') || '1');
                if (currentScale > 1) {
                    container.classList.add('draggable');
                } else {
                    container.classList.remove('draggable');
                }
            }
        }

        window.OrgChartTool.UIController = UIController;

    })();

    // 8. Main Application
    (function() {
        'use strict';

        class OrganizationChartApp {
            constructor() {
                this.version = '4.0.0-table-editor';
                this.initialized = false;
                this.uiController = null;
                
                this.initialize();
            }

            async initialize() {
                try {
                    console.log(`Organization Chart Tool v${this.version} - Initializing...`);
                    
                    if (document.readyState === 'loading') {
                        await new Promise(resolve => {
                            document.addEventListener('DOMContentLoaded', resolve);
                        });
                    }
                    
                    this.initializeModules();
                    this.setupGlobalFunctions();
                    
                    this.initialized = true;
                    console.log('Organization Chart Tool - Ready!');
                    
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showFatalError(error);
                }
            }

            initializeModules() {
                try {
                    this.uiController = new window.OrgChartTool.UIController();
                    window.OrgChartTool.Config.LanguageManager.initialize();
                    
                    console.log('All modules initialized successfully');
                } catch (error) {
                    console.error('Module initialization failed:', error);
                    throw error;
                }
            }

            setupGlobalFunctions() {
                window.loadSampleData = () => this.uiController.loadSampleData();
                window.generateChart = () => this.uiController.generateChart();
                window.toggleView = () => this.uiController.toggleView();
                window.exportSVG = () => this.uiController.exportSVG();
                window.exportPNG = () => this.uiController.exportPNG();
                window.exportHTML = () => this.uiController.exportHTML();
                window.exportEmptyTable = () => this.uiController.exportEmptyTable();
                window.exportCurrentData = () => this.uiController.exportCurrentData();
            }

            getInfo() {
                return {
                    version: this.version,
                    initialized: this.initialized,
                    hasData: this.uiController?.currentData?.length > 0,
                    timestamp: new Date().toISOString()
                };
            }

            showFatalError(error) {
                document.body.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #d32f2f;">
                        <h2>🚨 Fatal Error</h2>
                        <p>${error.message}</p>
                        <button onclick="location.reload()">Reload Page</button>
                    </div>
                `;
            }
        }

        window.OrgChartTool.App = new OrganizationChartApp();

    })();

    </script>
</body>
</html>